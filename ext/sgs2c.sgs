
///////////////////////////////////////////////////////////
/// E / X / P / E / R / I / M / E / N / T / A / L /////////
///////////////////////////////////////////////////////////


include "string", "io", "fmt", "../bin/sgsmeta";

meta_globals();

function E( txt ){ println( "ERROR: ", txt ); app_exit(1); }


///////////////////////////////////////////////////////////

function sgs_isconstarg( arg ){ return arg & 0x100 != 0; }
function sgs_getconstarg( arg ){ return arg & 0xff; }
function sgs_srcptr( arg ){ return if( sgs_isconstarg( arg ), "CN+" $ sgs_getconstarg( arg ), "T+" $ arg ); }
function sgs_e2off( arg ){ arg &= 0xffff; if( arg > 0x7fff ) arg -= 0x10000; return arg; }

///////////////////////////////////////////////////////////

global c_header = "#include <sgscript.h>\n";

function c_func_wrapper( fdata, fname )
{
	return "\nint " $ fname $ "( SGS_CTX )\n{" $
		string_replace( fdata, "\n", "\n\t" ) $ "\n}\n";
}

function c_ifunc_wrapper( fdata, fname )
{
	return "\nstatic int " $ fname $ "( SGS_CTX, sgs_VarObj* obj )\n{" $
		string_replace( fdata, "\n", "\n\t" ) $ "\n}\n";
}

function c_sfunc_wrapper( fdata, fname )
{
	return "\nstatic int " $ fname $ "( SGS_CTX, sgs_Variable* out )\n{" $
		string_replace( fdata, "\n", "\n\t" ) $ "\n}\n";
}

function c_safe_str( str )
{
	out = "";
	strlen = str.length;
	for( i = 0; i < strlen; ++i )
	{
		c = str[ i ];
		if( c == "\"" )
			out $= "\\\"";
		else if( c < "\x20" || c >= "\x7f" )
			out $= fmt_text( "\\x{x2p0}", string_charcode( c ) );
		else
			out $= c;
	}
	return out;
}

function c_compile_label( pos )
{
	return "\n_op" $ pos $ ":;";
}

function c_compile_jump( pos )
{
	return "goto _op" $ pos $ ";";
}

function c_compile_incdec( R, A, inc )
{
	return "\nsgs_IncDec( C, T+" $ R $ ", " $ sgs_srcptr( A ) $ ", " $ inc $ " );";
}

function c_compile_arith( R, A, B, type )
{
	return "\nsgs_ArithOp( C, T+" $ R $ ", " $ sgs_srcptr( A )
		$ ", " $ if( B === null, "NULL", sgs_srcptr( B ) ) $ ", SGS_EOP_" $ type $ " );";
}

function c_compile_binop( R, A, B, op )
{
	getA = "sgs_GetIntP( C, " $ sgs_srcptr( A ) $ " )";
	return "\n{ sgs_Int V = " $ if( B === null, op $ getA,
		getA $ " " $ op $ " sgs_GetIntP( C, " $ sgs_srcptr( B ) $ " )" ) $ ";"
		$ "\nsgs_Release( C, T+" $ R $ " ); sgs_InitInt( T+" $ R $ ", V ); }";
}

function c_compile_comparison( R, A, B, sign )
{
	strict = false;
	if( sign == "===" || sign == "!==" )
	{
		sign = string_part( sign, 0, 2 );
		strict = true;
		dsv = if( sign == "==", "0", "1" );
	}
	spA = sgs_srcptr( A );
	spB = sgs_srcptr( B );
	out = "\n{ int V = ";
	if( strict )
		out $= "!sgs_EqualTypes( " $ spA $ ", " $ spB $ " ) ? " $ dsv $ " : ";
	out $= "(sgs_Compare( C, " $ spA $ ", " $ spB $ " ) " $ sign $ " 0);";
	out $= "\nsgs_Release( C, T+" $ R $ " ); sgs_InitBool( T+" $ R $ ", V ); }";
	return out;
}

function c_compile_initop( R, what, count )
{
	return "\nsgs_Release( C, T+" $ R $ " );"
		$ "\nsgs_Create" $ what $ "( C, T+" $ R $ ", " $ count $ " );";
}

function c_compile_const_init( fdata )
{
	output = "";
	foreach( i, cn : fdata.consts )
	{
		ty = cn.type;
		if( ty == VT_NULL )
			output $= "\nsgs_InitNull( CN+" $ i $ " );";
		else if( ty == VT_BOOL )
			output $= "\nsgs_InitBool( CN+" $ i $ ", " $ if( cn.data, 1, 0 ) $ " );";
		else if( ty == VT_INT )
			output $= "\nsgs_InitInt( CN+" $ i $ ", " $ cn.data $ "LL );";
		else if( ty == VT_REAL )
			output $= "\nsgs_InitReal( CN+" $ i $ ", " $ fmt_text( "{g.1024}", cn.data ) $ " );";
		else if( ty == VT_STRING )
		{
			output $= "\nsgs_InitStringBuf( C, CN+" $ i $
				", \"" $ c_safe_str( cn.data ) $ "\", " $ cn.data.length $ " );";
		}
		else if( ty == VT_FUNC )
			output $= "\nI" $ cn.data.name $ "( C, CN+" $ i $ " );";
	}
	return output;
}

function c_compile_func_inner( fdata, iswhole )
{
	output = "\nint ret = 0;"
		$ "\nSGSFN( \"" $ c_safe_str( fdata.rname ) $ "\" );";
	if( fdata.numargs + fdata.numtmp )
		output $= "\nsgs_Variable T[ " $ fdata.numargs + fdata.numtmp $ " ];";
	if( fdata.consts.size )
	{
		if( iswhole )
			output $= "\nsgs_Variable CN[ " $ fdata.consts.size $ " ];";
		else
			output $= "\nsgs_Variable* CN = (sgs_Variable*) obj->data;";
	}
	
	if( fdata.gotthis )
		output $= "\nsgs_Method( C );";
	
	for( i = 0; i < fdata.numargs; ++i )
		output $= "\nsgs_PushItem( C, " $ i $ " );\nsgs_StoreVariable( C, T+" $ i $ " );";
	
	if( fdata.numtmp )
	{
		output $= "\n{ int i; for( i = " $ fdata.numargs $ "; i < " $ fdata.numargs + fdata.numtmp $ "; ++i )"
			$ "\n\tT[ i ].type = SGS_VT_NULL; }";
	}
	
	if( iswhole )
		output $= c_compile_const_init( fdata );
	
	// walk all instructions to get all jump positions
	jumppos = {};
	foreach( op_pos, op : fdata.code )
	{
		if( op.op == SI_JUMP ||
			op.op == SI_JMPT ||
			op.op == SI_JMPF ||
			op.op == SI_JMPN ||
			op.op == SI_FORJUMP )
			jumppos[ op_pos + 1 + sgs_e2off( op.e ) ] = true;
	}
	
	foreach( op_pos, op : fdata.code )
	{
		if( isset( jumppos, op_pos ) )
			output $= c_compile_label( op_pos );
		
		output $= "\n// " $ meta_opname( op.op );
		
		if(0);
		
		// STACK
		else if( op.op == SI_PUSH )
		{
			output $= "\nsgs_PushVariable( C, " $ sgs_srcptr( op.b ) $ " );";
		}
		
		// FLOW CONTROL
		else if( op.op == SI_RETN )
		{
			output $= "\nret = " $ op.a $ ";\ngoto _ret;";
		}
		else if( op.op == SI_JUMP )
		{
			output $= "\n" $ c_compile_jump( op_pos + 1 + sgs_e2off( op.e ) );
		}
		else if( op.op == SI_JMPT )
		{
			output $= "\nif( sgs_GetBoolP( C, " $ sgs_srcptr( op.c )
				$ " ) ) " $ c_compile_jump( op_pos + 1 + sgs_e2off( op.e ) );
		}
		else if( op.op == SI_JMPF )
		{
			output $= "\nif( !sgs_GetBoolP( C, " $ sgs_srcptr( op.c )
				$ " ) ) " $ c_compile_jump( op_pos + 1 + sgs_e2off( op.e ) );
		}
		else if( op.op == SI_JMPN )
		{
			output $= "\nif( sgs_ItemType( C, " $ sgs_srcptr( op.c )
				$ " ) == SGS_VT_NULL ) " $ c_compile_jump( op_pos + 1 + sgs_e2off( op.e ) );
		}
		else if( op.op == SI_CALL )
		{
			call_from = op.b & 0xff;
			call_to = op.c;
			call_gotthis = ( op.b & 0x100 ) != 0;
			call_numargs = call_to - call_from - call_gotthis;
			call_expect = op.a;
			
			for( i = call_from; i < call_to; ++i )
				output $= "\nsgs_PushVariable( C, T+" $ i $ " );";
			output $= "\nsgs_FCallP( C, " $ sgs_srcptr( call_to ) $ ", " $ call_numargs $
				", " $ call_expect $ ", " $ if( call_gotthis, 1, 0 ) $ " );";
			if( call_expect )
			{
				for( i = call_expect - 1; i >= 0; --i )
				{
					si = call_from + i;
					output $= "\nsgs_Release( C, T+" $ si $ " );";
					output $= "\nsgs_StoreVariable( C, T+" $ si $ " );";
				}
			}
		}
		
		// ITERATORS
		else if( op.op == SI_FORPREP )
		{
			if( op.a == op.b )
			{
				output $= "\n{ sgs_Variable V = T[" $ op.a $ "];"
					$ "\nsgs_GetIteratorP( C, " $ sgs_srcptr( op.b ) $ ", T+" $ op.a $ " );"
					$ "\nsgs_Release( C, &V ); }";
			}
			else
			{
				output $= "\nsgs_Release( C, T+" $ op.a $ " );"
					$ "\nsgs_GetIteratorP( C, " $ sgs_srcptr( op.b ) $ ", T+" $ op.a $ " );";
			}
		}
		else if( op.op == SI_FORLOAD )
		{
			if( op.a == op.b || op.a == op.c )
			{
				output $= "\n{";
				if( op.b & 0xff == op.b ) output $= " sgs_Variable VB = T[" $ op.b $ "];";
				if( op.c & 0xff == op.c ) output $= " sgs_Variable VC = T[" $ op.c $ "];";
				output $= "\nsgs_IterGetDataP( C, " $ sgs_srcptr( op.a ) $ ", "
					$ if( op.b & 0xff == op.b, "T+" $ op.b, "NULL" ) $ ", "
					$ if( op.c & 0xff == op.c, "T+" $ op.c, "NULL" ) $ " );";
				if( op.b & 0xff == op.b ) output $= "sgs_Release( C, &VB ); ";
				if( op.c & 0xff == op.c ) output $= "sgs_Release( C, &VC ); ";
				output $= "}";
			}
			else
			{
				if( op.b & 0xff == op.b ) output $= "\nsgs_Release( C, T+" $ op.b $ " );";
				if( op.c & 0xff == op.c ) output $= "\nsgs_Release( C, T+" $ op.c $ " );";
				output $= "\nsgs_IterGetDataP( C, " $ sgs_srcptr( op.a ) $ ", "
					$ if( op.b & 0xff == op.b, "T+" $ op.b, "NULL" ) $ ", "
					$ if( op.c & 0xff == op.c, "T+" $ op.c, "NULL" ) $ " );";
			}
		}
		else if( op.op == SI_FORJUMP )
		{
			output $= "\nif( sgs_IterAdvanceP( C, " $ sgs_srcptr( op.c ) $ " ) <= 0 )"
				$ "\n\t" $ c_compile_jump( op_pos + 1 + sgs_e2off( op.e ) );
		}
		
		// SUBITEMS
		else if( op.op == SI_LOADCONST )
		{
			output $= "\nsgs_Assign( C, T+" $ op.c $ ", CN+" $ sgs_e2off( op.e ) $ " );";
		}
		else if( op.op == SI_GETVAR )
		{
			if( op.a == op.b )
			{
				output $= "\n{ sgs_Variable V = T[" $ op.a $ "];"
					$ "\nsgs_GetGlobalPP( C, " $ sgs_srcptr( op.b ) $ ", T+" $ op.a $ " );"
					$ "\nsgs_Release( C, &V ); }";
			}
			else
			{
				output $= "\nsgs_Release( C, T+" $ op.a $ " );"
					$ "\nsgs_GetGlobalPP( C, " $ sgs_srcptr( op.b ) $ ", T+" $ op.a $ " );";
			}
		}
		else if( op.op == SI_SETVAR )
		{
			output $= "\nsgs_SetGlobalPP( C, " $ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ " );";
		}
		else if( op.op == SI_GETPROP )
		{
			if( op.a == op.b || op.a == op.c )
			{
				output $= "\n{ sgs_Variable V = T[" $ op.a $ "];"
					$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
					$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 1 );"
					$ "\nsgs_Release( C, &V ); }";
			}
			else
			{
				output $= "\nsgs_Release( C, T+" $ op.a $ " );"
					$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
					$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 1 );";
			}
		}
		else if( op.op == SI_SETPROP )
		{
			output $= "\nsgs_SetIndexPPP( C, " $ sgs_srcptr( op.a ) $ ", "
				$ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ ", 1 );";
		}
		else if( op.op == SI_GETINDEX )
		{
			if( op.a == op.b || op.a == op.c )
			{
				output $= "\n{ sgs_Variable V = T[" $ op.a $ "];"
					$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
					$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 0 );"
					$ "\nsgs_Release( C, &V ); }";
			}
			else
			{
				output $= "\nsgs_Release( C, T+" $ op.a $ " );"
					$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
					$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 0 );";
			}
		}
		else if( op.op == SI_SETINDEX )
		{
			output $= "\nsgs_SetIndexPPP( C, " $ sgs_srcptr( op.a ) $ ", "
				$ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ ", 0 );";
		}
		
		// CLOSURES
		else if( op.op == SI_GENCLSR )
		{
			output $= "\nsgs_ClPushNulls( C, " $ op.a $ " );";
		}
		else if( op.op == SI_PUSHCLSR )
		{
			output $= "\nsgs_ClPushItem( C, " $ op.a $ " );";
		}
		else if( op.op == SI_MAKECLSR )
		{
			if( op.a == op.b )
			{
				output $= "\n{ sgs_Variable V = T[" $ op.a $ "];"
					$ "\nsgs_MakeClosure( C, " $ sgs_srcptr( op.b ) $ ", " $ op.c $ ", T+" $ op.a $ " );"
					$ "\nsgs_Release( C, &V ); }";
			}
			else
			{
				output $= "\nsgs_MakeClosure( C, " $ sgs_srcptr( op.b ) $ ", " $ op.c $ ", T+" $ op.a $ " );";
			}
		}
		else if( op.op == SI_GETCLSR )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_ClGetItem( C, " $ op.b $ ", T+" $ op.a $ " );";
		}
		else if( op.op == SI_SETCLSR )
		{
			output $= "\nsgs_ClSetItem( C, " $ op.b $ ", " $ sgs_srcptr( op.c ) $ " );";
		}
		
		// SPECIAL OPERATORS
		else if( op.op == SI_SET )
		{
			output $= "\nsgs_Assign( C, T+" $ op.a $ ", " $ sgs_srcptr( op.b ) $ " );";
		}
		else if( op.op == SI_MCONCAT )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_StringConcat( C, " $ op.b $ " );"
				$ "\nsgs_StoreVariable( C, T+" $ op.a $ " );";
		}
		else if( op.op == SI_CONCAT )
		{
			output $= "\nsgs_PushVariable( C, " $ sgs_srcptr( op.b ) $ " );"
				$ "\nsgs_PushVariable( C, " $ sgs_srcptr( op.c ) $ " );"
				$ "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_StringConcat( C, 2 );\nsgs_StoreVariable( C, T+" $ op.a $ " );";
		}
		else if( op.op == SI_NEGATE ) output $= c_compile_arith( op.a, op.b, null, "NEGATE" );
		else if( op.op == SI_BOOL_INV )
		{
			output $= "\n{ int V = !sgs_GetBoolP( C, " $ sgs_srcptr( op.b ) $ " );"
				$ "\nsgs_Release( C, T+" $ op.a $ " ); sgs_InitBool( T+" $ op.a $ ", V ); }";
		}
		else if( op.op == SI_INVERT ) output $= c_compile_binop( op.a, op.b, null, "~" );
		
		// ARITHMETIC OPS
		else if( op.op == SI_INC ) output $= c_compile_incdec( op.a, op.b, 1 );
		else if( op.op == SI_DEC ) output $= c_compile_incdec( op.a, op.b, 0 );
		else if( op.op == SI_ADD ) output $= c_compile_arith( op.a, op.b, op.c, "ADD" );
		else if( op.op == SI_SUB ) output $= c_compile_arith( op.a, op.b, op.c, "SUB" );
		else if( op.op == SI_MUL ) output $= c_compile_arith( op.a, op.b, op.c, "MUL" );
		else if( op.op == SI_DIV ) output $= c_compile_arith( op.a, op.b, op.c, "DIV" );
		else if( op.op == SI_MOD ) output $= c_compile_arith( op.a, op.b, op.c, "MOD" );
		
		// BINARY OPS
		else if( op.op == SI_AND ) output $= c_compile_binop( op.a, op.b, op.c, "&" );
		else if( op.op == SI_OR ) output $= c_compile_binop( op.a, op.b, op.c, "|" );
		else if( op.op == SI_XOR ) output $= c_compile_binop( op.a, op.b, op.c, "^" );
		else if( op.op == SI_LSH ) output $= c_compile_binop( op.a, op.b, op.c, "<<" );
		else if( op.op == SI_RSH ) output $= c_compile_binop( op.a, op.b, op.c, ">>" );
		
		// COMPARISON
		else if( op.op == SI_SEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "===" );
		else if( op.op == SI_SNEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "!==" );
		else if( op.op == SI_EQ ) output $= c_compile_comparison( op.a, op.b, op.c, "==" );
		else if( op.op == SI_NEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "!=" );
		else if( op.op == SI_LT ) output $= c_compile_comparison( op.a, op.b, op.c, "<" );
		else if( op.op == SI_GT ) output $= c_compile_comparison( op.a, op.b, op.c, ">" );
		else if( op.op == SI_LTE ) output $= c_compile_comparison( op.a, op.b, op.c, "<=" );
		else if( op.op == SI_GTE ) output $= c_compile_comparison( op.a, op.b, op.c, ">=" );
		else if( op.op == SI_RAWCMP ) output $= c_compile_comparison( op.a, op.b, op.c, "<=>" );
		
		// SPECIAL ACTIONS
		else if( op.op == SI_ARRAY ) output $= c_compile_initop( op.a, "Array", op.b );
		else if( op.op == SI_DICT ) output $= c_compile_initop( op.a, "Dict", op.b );
	}
	
	op_pos = fdata.code.size;
	if( isset( jumppos, op_pos ) )
		output $= c_compile_label( op_pos );
	
	output $= "\n// ---";
	
	output $= "\n_ret:";
	if( fdata.numargs + fdata.numtmp )
		output $= "\nsgs_ReleaseArray( C, T, " $ fdata.numargs + fdata.numtmp $ " );";
	if( iswhole )
		output $= "\nsgs_ReleaseArray( C, CN, " $ fdata.consts.size $ " );";
	output $= "\nreturn ret;";
	
	return output;
}

function c_compile_dtor_inner( fdata )
{
	return "\nsgs_ReleaseArray( C, (sgs_Variable*) obj->data, " $ fdata.consts.size $ " );"
		$ "\nreturn SGS_SUCCESS;";
}

function c_compile_gcmk_inner( fdata )
{
	return "\nreturn sgs_GCMarkArray( C, (sgs_Variable*) obj->data, " $ fdata.consts.size $ " );";
}

function c_compile_init_inner( fdata, funcname )
{
	if( fdata.consts.size )
		output = "\nsgs_Variable* CN = (sgs_Variable*)\n\t";
	else
		output = "\n";
	output $= "sgs_CreateObjectIPA( C, out, sizeof(sgs_Variable) * "
		$ fdata.consts.size $ ", T" $ funcname $ " );";
	output $= c_compile_const_init( fdata );
	output $= "\nreturn SGS_SUCCESS;";
	return output;
}

function c_compile_func( fdata, name_ovr )
{
	output = "";
	foreach( i, cn : fdata.consts )
	{
		cn.name = "C" $ i;
		if( cn.type == VT_FUNC )
		{
			if( cn.data.name )
			{
				cn.data.rname = cn.data.name;
				cn.data.name = fdata.name $ "__" $ cn.data.name;
			}
			else
			{
				cn.data.rname = "<anonymous>";
				cn.data.name = fdata.name $ "__" $ i $ "_anon";
			}
			output $= c_compile_func( cn.data );
		}
	}
	
	funcname = name_ovr || fdata.name;
	if( name_ovr === "sgscript_main" )
	{
		output $= c_func_wrapper( c_compile_func_inner( fdata, true ), funcname );
	}
	else
	{
		output $= c_ifunc_wrapper( c_compile_func_inner( fdata ), "F" $ funcname );
		output $= c_ifunc_wrapper( c_compile_dtor_inner( fdata ), "D" $ funcname );
		output $= c_ifunc_wrapper( c_compile_gcmk_inner( fdata ), "G" $ funcname );
		output $= "\nstatic sgs_ObjInterface T" $ funcname $ "[1] ="
			$ "\n{{\n\t\"func\","
			$ "\n\tD" $ funcname $ ", G" $ funcname $ ","
			$ "\n\tNULL, NULL,"
			$ "\n\tNULL, NULL, NULL, NULL,"
			$ "\n\tF" $ funcname $ ", NULL\n}};\n";
		output $= c_sfunc_wrapper( c_compile_init_inner( fdata, funcname ), "I" $ funcname );
	}
	return output;
}

function generate_c_file( cdata )
{
	cdata = meta_unpack( cdata );
	if( cdata === null )
		return E( "Failed to parse the compiled script (internal error)" );
	cdata.rname = "<main>";
	cdata.name = "sgs";
	return c_header $ c_compile_func( cdata, "sgscript_main" );
}

///////////////////////////////////////////////////////////


println( "SGS 2 C" );

if( argc < 2 )
	return E( "Error: script not specified" );

IN = argv[1];
if( argc >= 3 )
	OUT = argv[2];
else
	OUT = IN $ ".c";

println( "Script: " $ IN );

script_data = io_file_read( IN );
if( !script_data ) return E( "Error: could not read script" );

(compiled_data, errors) = compile_sgs( script_data );
if( !compiled_data )
	return E( "Error: could not compile script: " $ string_implode( errors, ", " ) );

println( "Script compiled successfully!" );

c_data = generate_c_file( compiled_data );
if( !c_data )
	return;

if( !io_file_write( OUT, c_data ) )
	return E( "Failed to save the C file" );

println( "C file was generated and saved successfully" );
