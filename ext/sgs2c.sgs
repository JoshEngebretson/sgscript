
///////////////////////////////////////////////////////////
/// E / X / P / E / R / I / M / E / N / T / A / L /////////
///////////////////////////////////////////////////////////

// Coverage:
// +
// PUSH, RETN, JUMP, JMPT, JMPF, CALL, LOADCONST
// GETVAR, SETVAR, GETPROP, SETPROP, GETINDEX, SETINDEX
// SET, MCONCAT, CONCAT
// SEQ, SNEQ, EQ, NEQ, LT, GTE, GT, LTE
// ARRAY, DICT
// -
// FORPREP, FORLOAD, FORJUMP
// GENCLSR, PUSHCLSR, MAKECLSR, GETCLSR, SETCLSR
// NEGATE, BOOL_INV, INVERT
// INC, DEC, ADD, SUB, MUL, DIV, MOD
// AND, OR, XOR, LSH, RSH


include "string", "io", "fmt", "../bin/sgsmeta";

meta_globals();

function E( txt ){ println( txt ); }


///////////////////////////////////////////////////////////

function sgs_isconstarg( arg ){ return arg & 0x100 != 0; }
function sgs_getconstarg( arg ){ return arg & 0xff; }
function sgs_srcptr( arg ){ return if( sgs_isconstarg( arg ), "CN+" $ sgs_getconstarg( arg ), "T+" $ arg ); }

///////////////////////////////////////////////////////////

global c_header = "
#include <sgscript.h>

";

function c_func_wrapper( fdata, fname )
{
	return "\nint " $ fname $ "( SGS_CTX )\n{" $
		string_replace( fdata, "\n", "\n\t" ) $ "\n}\n";
}

function c_safe_str( str )
{
	out = "";
	strlen = str.length;
	for( i = 0; i < strlen; ++i )
	{
		c = str[ i ];
		if( c == "\"" )
			out $= "\\\"";
		else if( c < "\x20" || c >= "\x7f" )
			out $= fmt_text( "\\x{x2p0}", string_charcode( c ) );
		else
			out $= c;
	}
	return out;
}

function c_compile_label( pos )
{
	return "\n_op" $ pos $ ":;";
}

function c_compile_jump( pos )
{
	return "goto _op" $ pos $ ";";
}

function c_compile_comparison( R, A, B, sign )
{
	strict = false;
	if( sign == "===" || sign == "!==" )
	{
		sign = string_part( sign, 0, 2 );
		strict = true;
		dsv = if( sign == "==", "0", "1" );
	}
	out = "\nsgs_Release( C, T+" $ R $ " );"
		$ "\nsgs_InitBool( T+" $ R $ ", ";
	spA = sgs_srcptr( A );
	spB = sgs_srcptr( B );
	if( strict )
		out $= "!sgs_EqualTypes( " $ spA $ ", " $ spB $ " ) ? " $ dsv $ " : ";
	out $= "(sgs_Compare( C, " $ spA $ ", " $ spB $ " ) " $ sign $ " 0) );";
	return out;
}

function c_compile_initop( R, what, count )
{
	return "\nsgs_Release( C, T+" $ R $ " );"
		$ "\nsgs_Init" $ what $ "( C, T+" $ R $ ", " $ count $ " );";
}

function c_compile_func_inner( fdata )
{
	lastreturn = false;
	
	output = "";
	if( fdata.numtmp )
		output $= "\nsgs_Variable T[ " $ fdata.numtmp $ " ];";
	if( fdata.consts.size )
		output $= "\nsgs_Variable CN[ " $ fdata.consts.size $ " ];";
	
	for( i = 0; i < fdata.numtmp; ++i )
		output $= "\nsgs_InitNull( T+" $ i $ " );";
	foreach( i, cn : fdata.consts )
	{
		ty = cn.type;
		if( ty == VT_NULL )
			output $= "\nsgs_InitNull( CN+" $ i $ " );";
		else if( ty == VT_BOOL )
			output $= "\nsgs_InitBool( CN+" $ i $ ", " $ if( cn.data, 1, 0 ) $ " );";
		else if( ty == VT_INT )
			output $= "\nsgs_InitInt( CN+" $ i $ ", " $ cn.data $ "LL );";
		else if( ty == VT_REAL )
			output $= "\nsgs_InitReal( CN+" $ i $ ", " $ fmt_text( "{g.1024}", cn.data ) $ " );";
		else if( ty == VT_STRING )
		{
			output $= "\nsgs_InitStringBuf( C, CN+" $ i $
				", \"" $ c_safe_str( cn.data ) $ "\", " $ cn.data.length $ " );";
		}
		else if( ty == VT_FUNC )
			output $= "\n// (TODO FUNC CONSTANT) " $ cn.data.name;
	}
	
	// walk all instructions to get all jump positions
	jumppos = {};
	foreach( op_pos, op : fdata.code )
	{
		if( op.op == SI_JUMP || op.op == SI_JMPT || op.op == SI_JMPF )
			jumppos[ op_pos + 1 + op.e ] = true;
	}
	
	foreach( op_pos, op : fdata.code )
	{
		output $= "\n// " $ meta_opname( op.op );
		lastreturn = false;
		
		if( isset( jumppos, op_pos ) )
			output $= c_compile_label( op_pos );
		
		if(0);
		
		// STACK
		else if( op.op == SI_PUSH )
		{
			output $= "\nsgs_PushVariable( C, " $ sgs_srcptr( op.b ) $ " );";
		}
		
		// FLOW CONTROL
		else if( op.op == SI_RETN )
		{
			output $= "\nreturn " $ op.a $ ";";
			lastreturn = true;
		}
		else if( op.op == SI_JUMP )
		{
			output $= "\n" $ c_compile_jump( op_pos + 1 + op.e );
		}
		else if( op.op == SI_JMPT )
		{
			output $= "\nif( sgs_GetBoolP( C, " $ sgs_srcptr( op.c )
				$ " ) ) " $ c_compile_jump( op_pos + 1 + op.e );
		}
		else if( op.op == SI_JMPF )
		{
			output $= "\nif( !sgs_GetBoolP( C, " $ sgs_srcptr( op.c )
				$ " ) ) " $ c_compile_jump( op_pos + 1 + op.e );
		}
		else if( op.op == SI_CALL )
		{
			call_from = op.b & 0xff;
			call_to = op.c;
			call_gotthis = ( op.b & 0x100 ) != 0;
			call_numargs = call_to - call_from - call_gotthis;
			call_expect = op.a;
			
			for( i = call_from; i < call_to; ++i )
				output $= "\nsgs_PushVariable( C, T+" $ i $ " );";
			output $= "\nsgs_FCallP( C, " $ sgs_srcptr( call_to ) $ ", " $ call_numargs $
				", " $ call_expect $ ", " $ if( call_gotthis, 1, 0 ) $ " );";
			if( call_expect )
			{
				for( i = call_expect - 1; i >= 0; --i )
				{
					output $= "\nsgs_Release( C, T+" $ i $ " );";
					output $= "\nsgs_StoreVariable( C, T+" $ i $ " );";
				}
			}
		}
		
		// ITERATORS
		
		// SUBITEMS
		else if( op.op == SI_LOADCONST )
		{
			output $= "\nsgs_Assign( C, T+" $ op.c $ ", CN+" $ op.e $ " );";
		}
		else if( op.op == SI_GETVAR )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_GetGlobalPP( C, " $ sgs_srcptr( op.b ) $ ", T+" $ op.a $ " );";
		}
		else if( op.op == SI_SETVAR )
		{
			output $= "\nsgs_SetGlobalPP( C, " $ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ " );";
		}
		else if( op.op == SI_GETPROP )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
				$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 1 );";
		}
		else if( op.op == SI_SETPROP )
		{
			output $= "\nsgs_SetIndexPPP( C, " $ sgs_srcptr( op.a ) $ ", "
				$ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ ", 1 );";
		}
		else if( op.op == SI_GETINDEX )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_GetIndexPPP( C, " $ sgs_srcptr( op.b ) $ ", "
				$ sgs_srcptr( op.c ) $ ", T+" $ op.a $ ", 0 );";
		}
		else if( op.op == SI_SETINDEX )
		{
			output $= "\nsgs_SetIndexPPP( C, " $ sgs_srcptr( op.a ) $ ", "
				$ sgs_srcptr( op.b ) $ ", " $ sgs_srcptr( op.c ) $ ", 0 );";
		}
		
		// CLOSURES
		
		// SPECIAL OPERATORS
		else if( op.op == SI_SET )
		{
			output $= "\nsgs_Assign( C, T+" $ op.a $ ", " $ sgs_srcptr( op.b ) $ " );";
		}
		else if( op.op == SI_MCONCAT )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_StringConcat( C, " $ op.b $ " );"
				$ "\nsgs_StoreVariable( C, T+" $ op.a $ " );";
		}
		else if( op.op == SI_CONCAT )
		{
			output $= "\nsgs_Release( C, T+" $ op.a $ " );"
				$ "\nsgs_PushVariable( C, " $ sgs_srcptr( op.b ) $ " );"
				$ "\nsgs_PushVariable( C, " $ sgs_srcptr( op.c ) $ " );"
				$ "\nsgs_StringConcat( C, 2 );\nsgs_StoreVariable( C, T+" $ op.a $ " );";
		}
		
		// COMPARISON
		else if( op.op == SI_SEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "===" );
		else if( op.op == SI_SNEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "!==" );
		else if( op.op == SI_EQ ) output $= c_compile_comparison( op.a, op.b, op.c, "==" );
		else if( op.op == SI_NEQ ) output $= c_compile_comparison( op.a, op.b, op.c, "!=" );
		else if( op.op == SI_LT ) output $= c_compile_comparison( op.a, op.b, op.c, "<" );
		else if( op.op == SI_GT ) output $= c_compile_comparison( op.a, op.b, op.c, ">" );
		else if( op.op == SI_LTE ) output $= c_compile_comparison( op.a, op.b, op.c, "<=" );
		else if( op.op == SI_GTE ) output $= c_compile_comparison( op.a, op.b, op.c, ">=" );
		
		// SPECIAL ACTIONS
		else if( op.op == SI_ARRAY ) output $= c_compile_initop( op.a, "Array", op.b );
		else if( op.op == SI_DICT ) output $= c_compile_initop( op.a, "Dict", op.b );
	}
	
	op_pos = fdata.code.size;
	if( isset( jumppos, op_pos ) )
	{
		output $= c_compile_label( op_pos );
		lastreturn = false;
	}
	
	output $= "\n// ---";
	
	if( !lastreturn )
		output $= "\nreturn 0;";
	
	return output;
}

function c_compile_func( fdata, name_ovr )
{
	output = "";
	foreach( i, cn : fdata.consts )
	{
		cn.name = "C" $ i;
		if( cn.type == VT_FUNC )
		{
			cn.data.name = fdata.name $ "__" $ cn.data.name;
			output $= c_compile_func( cn.data );
		}
	}
	
	output $= c_func_wrapper( c_compile_func_inner( fdata ), name_ovr || fdata.name );
	return output;
}

function generate_c_file( cdata )
{
	cdata = meta_unpack( cdata );
	cdata.name = "sgs";
	return c_header $ c_compile_func( cdata, "sgscript_main" );
}

///////////////////////////////////////////////////////////


println( "SGS 2 C" );

if( argc != 2 ) return E( "Error: script not specified" );

script_name = argv[1];

println( "Script: " $ script_name );

script_data = io_file_read( script_name );
if( !script_data ) return E( "Error: could not read script" );

(compiled_data, errors) = compile_sgs( script_data );
if( !compiled_data )
	return E( "Error: could not compile script: " $ string_implode( errors, ", " ) );

println( "Script compiled successfully!" );

c_data = generate_c_file( compiled_data );
if( !c_data )
	return;

if( !io_file_write( script_name $ ".c", c_data ) )
	return E( "Failed to save the C file" );

println( "C file was generated and saved successfully" );
