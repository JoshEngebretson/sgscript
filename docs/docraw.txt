
======================
== S G S c r i p t = =
======================

=
== API/BASIC
=


sgs_CreateEngine [function alias]

== sgs_Context* sgs_CreateEngine()
=== returns a new scripting engine context

- alias to `sgs_CreateEngineExt( sgs_DefaultMemFunc, NULL )`


sgs_CreateEngineExt [function]

== sgs_Context* sgs_CreateEngineExt( sgs_MemFunc memfunc, void* mfuserdata )
=== returns a new scripting engine context, attached to the specified allocator


sgs_DestroyEngine [function]

== sgs_DestroyEngine( sgs_Context* C )
=== destroys the passed context and frees all memory associated to it


sgs_ExecString [function alias]

== SGSRESULT sgs_ExecString( sgs_Context* C, const char* str )
=== compiles and executes a string of text

- leaves the stack the same as it was before the call
- alias to `sgs_ExecBuffer( C, str, SGS_STRINGLENGTHFUNC( str ) )`
- theoretically bytecode is supported but it will most probably be trimmed by the string length function, unless a different string termination mark is used, and a different string length function to detect it is set

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_ExecBuffer [function alias]

== SGSRESULT sgs_ExecBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size )
=== compiles and executes a buffer of text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalBuffer( C, buf, size, NULL )`

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalString [function alias]

== SGSRESULT sgs_EvalString( sgs_Context* C, const char* str, int* rvc )
=== compiles and executes a string of text, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call
- alias to sgs_EvalBuffer( C, str, SGS_STRINGLENGTHFUNC( str ), rvc )

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalBuffer [function]

== SGSRESULT sgs_EvalBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size, int* rvc )
=== compiles and executes a buffer of text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_ExecFile [function alias]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename )
=== compiles and executes a file containing script text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalFile( C, filename, NULL )`

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalFile [function]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename, int* rvc )
=== compiles and executes a file containing script text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== return values
- SGS_SUCCESS: operation was successful
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_LoadLib_[Fmt|IO|Math|OS|String] [functions]

== SGSRESULT sgs_LoadLib_Fmt( sgs_Context* C )
== SGSRESULT sgs_LoadLib_IO( sgs_Context* C )
== SGSRESULT sgs_LoadLib_Math( sgs_Context* C )
== SGSRESULT sgs_LoadLib_OS( sgs_Context* C )
== SGSRESULT sgs_LoadLib_String( sgs_Context* C )
=== loads the library into the specified context

- it is generally unnecessary to check for these error codes

=== return values
- SGS_SUCCESS: operation was successful
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


sgs_Reg[Func|Int|Real]Const [struct]

== sgs_RegFuncConst { char* name; sgs_CFunc value; }
== sgs_RegIntConst { char* name; sgs_Integer value; }
== sgs_RegRealConst { char* name; sgs_Real value; }
=== a pair of null-terminated string and a scripting engine value type


sgs_Reg[Func|Int|Real]Consts [function]

== SGSRESULT sgs_RegFuncConsts( sgs_Context* C, const sgs_RegFuncConst* list, int size )
== SGSRESULT sgs_RegIntConsts( sgs_Context* C, const sgs_RegIntConst* list, int size )
== SGSRESULT sgs_RegRealConsts( sgs_Context* C, const sgs_RegRealConst* list, int size )
=== loads the specified list of constants in the context

- the end of list can be specified in two ways
-- set the size to `sizeof(list)/sizeof(list[0])`
-- set the size to -1 and end the list with `SGS_RC_END()`
-- using both at the same time should be reserved to special cases only

=== return values
- SGS_SUCCESS: operation was successful
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


=
== STDLIB/CORE
=


array() [function]

== array( ... )
=== returns an array, containing the arguments

- similar to the array literal, though somewhat limited

    array( "5", 6, 7.0 ) // same as ["5",6,7.0]


dict() [function]

== dict( [key, value, ...] )
=== returns a 'dict' (dictionary/hash table) object, containing the even arguments mapped to respective previous arguments

- if no arguments are passed, an empty dictionary is returned
- if an even number of arguments is passed, function returns null and emits a warning
- all even arguments must be strings or convertible to strings

    dict( "name", "John", "phone", 1234567890 ); // same as { name = "John", phone = 1234567890 }


class() [function]

== class( first, second )
=== returns a class object with `first` set as the primary data source and `second` set as the secondary/backup data source

- both arguments accept all kinds of variables but it's generally preferred to use only dicts / special objects
- refer to @CLASSES for more information on how class objects work and how to use them

    someCommonInterface = { printdata = function(){ print( this.data ); } };
    c = class( { data = "5" }, someCommonInterface );
    c.data = "6";
    c.printdata(); // prints 6


closure() [function]

== closure( callable, data )
=== returns a closure object with `callable` set as the callable variable and `data` set as the first argument for the closure call

- second argument accepts all kinds of variables, first requires a variable that can be called (SGScript function / C function / object with OP_CALL interface function defined)
- refer to @CLOSURES for more information on how closure objects work and how to use them

    counter = closure( function( data ){ return data[0]++; }, [0] );
    print( counter() ); print( counter() ); // prints "01"


isset() [function]

== isset( var, string key )
=== returns whether a property named `key` is accessible (exists) in variable `var`

    x = { a = 5 };
    isset( x, "a" ); // returns 'true'
    isset( x, "b" ); // returns 'false'
    isset( print, "thiscall" ); // returns 'true' -- works with built-in special properties too


unset() [function]

== unset( dict var, string key )
=== removes an entry named `key` from the dictionary `var`


clone() [function]

== clone( var )
=== creates a one-reference copy of the variable `var` or returns null and emits a warning on failure

- variables that are passed by value (null, bool, int, real, cfunc) or functions are returned as-is, since for value types all copies are same and functions are immutable -- TODO: what about strings? they're currently cloned

    x = { a = 5 };
    y = clone( x );
    z = x;
    x.a = 6;
    print( y.a ); // prints "5"
    print( z.a ); // prints "6"


get_keys() [function]

== get_keys( iterable var )
=== returns an array of keys found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_keys( [5,7,0] ); // returns [0,1,2]
    get_keys( {b=5,a=2} ); // returns ["b","a"]


get_values() [function]

== get_values( iterable var )
=== returns an array of values found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_values( [5,7,0] ); // returns [5,7,0]
    get_values( {b=5,a=2} ); // returns [5,2]


get_concat() [function]

== get_concat( iterable var, iterable var1, ... )
=== returns an array of values found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_concat( [1,2], {a="5",b=8} ); // returns [1,2,"5",8]


get_merged() [function]

== get_merged( iterable var, iterable var1, ... )
=== returns a dict of all key-value pairs found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_merged( [1,2], [3], {a="4"} ); // return {0=3,1=2,a="4"}


tobool() [function]

== tobool( var )
=== returns a boolean, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetBool / @sgs_ToBool in the C API

    tobool( 5 ); // returns 'true'
    tobool( "" ); // returns 'false'


toint() [function]

== toint( var )
=== returns an integer, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetInt / @sgs_ToInt in the C API

    toint( 5.4 ); // returns 5
    toint( "0xff" ); // returns 255


toreal() [function]

== toreal( var )
=== returns a real value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetReal / @sgs_ToReal in the C API

    toreal( 5 ); // returns 5.0
    toreal( "3e+2" ); // returns 3.0 -- exponential string values don't work (TODO: why)
    toreal( "0xff" ); // returns 255.0


tostring() [function]

== tostring( var )
=== returns a string value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_ToString in the C API

    tostring( 5 ); // returns "5"
    tostring( { "a" = "b" } ); // returns "{a=b}"


typeof() [function]

== typeof( var )
=== returns the type name of variable `var`, as string

- this function is equivalent to @sgs_Typeof in the C API

    typeof( 5 ); // returns "real"
    typeof( [] ); // returns "array"


typeid() [function]

== typeid( var )
=== returns the first 4 bits of the variable `var` type flags, as `int`

- returns one of the values mapped to VT_NULL/VT_BOOL/VT_INT/VT_REAL/VT_STRING/VT_FUNC/VT_CFUNC/VT_OBJECT
- this function is equivalent to @sgs_ItemType in the C API

    typeid( 5 ) == VT_REAL; // returns 'true'
    typeid( [] ); // returns 0x80 / VT_OBJECT


typeflags() [function]

== typeflags( var )
=== returns the type flags of the variable `var`, as `int`

- returns a bitfield, consisting of many different VT_* and VTF_* value combos, matching one of VTC_* values
- this function is equivalent to @sgs_ItemTypeExt in the C API

    typeflags( 5 ) == VTC_REAL; // returns 'true'
    typeid( [] ) & VT_OBJECT != 0; // returns 'true'
    typeid( "" ) & VTF_NUMERIC != 0; // returns 'false'


is_numeric() [function]

== is_numeric( var )
=== returns whether the variable `var` is numeric - one of bool/int/real or a numeric string

- all types that can always be converted to numbers are considered numeric, with two exceptions:
-- convertible objects are not numeric since validation requires an interface call and unnecessary interface calls cannot be made
-- null value is considered to be the lack of a better value, thus it cannot be considered valid, even though it always maps implicitly to the integer 0

    is_numeric( 12.124 ); // returns true
    is_numeric( "what" ); // returns false


is_callable() [function]

== is_callable( var )
=== returns whether the variable `var` is callable - a function (func/cfunc) or an object with OP_CALL defined

    is_callable( print ); // returns 'true'
    is_callable( closure( print, 5 ) ); // returns 'true'
    is_callable( 5 ); // returns 'false'


loadtypeflags() [function]

== loadtypeflags()
=== sets the globals beginning with VTF_ and VTC_

- since these features are expected to be rarely used, they're set to be loaded on-demand, not on startup

    isset( _G, "VTF_NUM" ); // returns 'false'
    loadtypeflags();
    isset( _G, "VTF_NUM" ); // returns 'true'


print(), println(), printlns() [functions]

== print( ... ), println( ... ), printlns( ... ),
=== passes all arguments, converted to strings, to the @output callback
- print passes arguments without modifications
- println passes a newline character after all variables
- printlns passes a newline character after each variable

    print( 5, "x" ); // prints "5x"
    println( 5, "x" ); // prints "5x\n"
    printlns( 5, "x" ); // prints "5\nx\n"


printvar() [function]

== printvar( var, int maxdepth = 5 )
=== passes a dump of the variable (informative string version) to the @output callback, allowing to optionally specify the maximum depth of the dump (how deep it is allowed to look for sub-variables)

    printvar( 5 ); // prints "real (5)"
    printvar( "wat" ); // prints "string [3] "wat""
    printvar( [{a=[{}]}], 2 ); /* prints:
    object (003C5F90) [0] array (1)
    [
      object (003C60A8) [1] dict (1)
      {
        ...
      }
    ]
    */


printvars() [function]

== printvars( var, ... )
=== same as a list of printvar(var); calls for each argument

- refer to @printvar() for more info


read_stdin() [function]

== read_stdin( bool all = false )
=== reads from the standard input

- if `all` is set to 'true', all standard input is read up to EOF (useful for piped input)
- if `all` is set to 'false' or not set at all, input is read up to (and excluding) the next newline character

    print "Name: "; name = read_stdin(); // waits for user input
    process( read_stdin(true) ); // loads all piped input


ftime() [function]

== ftime()
=== returns a value that is increased by a total of 1 each second (time), as real

- guaranteed to offer sub-second precision unless stated otherwise for any specific platform
- currently the precision is one millisecond

    start = ftime();
    do_something_big();
    println( "That took " $ ftime() - start $ " seconds." );


eval() [function]

== eval( string code )
=== returns the result of evaluating the passed `code` string as SGScript code

- this function is equivalent to @sgs_EvalBuffer/@sgs_EvalString in the C API

    eval("print 5;"); // prints 5


eval_file() [function]

== eval_file( string filename )
=== returns the result of evaluating the file pointed to by `filename` as SGScript code

- this function is equivalent to @sgs_EvalFile in the C API

    eval_file("myfile.sgs"); // ???


include_library() [function]

== include_library( string lib[, bool override ] )
=== loads the global variables of the specific library `lib` in the state, returns success, as `bool`, emits a warning on failure

- lib must be one of 'fmt', 'io', 'math', 'os', 'string'
- if `override` is specified, library will be reloaded even if it was already loaded before
- this function is equivalent to the sgs_LoadLib_* functions in the C API

    printvar( sin ); // warning, null
    include_library( "math" );
    printvar( sin ); // C function


include_file() [function]

== include_file( string file[, bool override ] )
=== executes the file pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available in one of the include paths (TODO: we don't have 'em yet)
- if `override` is specified, file will be reloaded even if it was already loaded before
- this function is equivalent to @sgs_ExecFile in the C API

    include_file( "something.sgs" ); // loads something
    include_file( "something.sgs" ); // does not load it again
    include_file( "something.sgs", true ); // loads it again


include_shared() [function]

== include_shared( string file[, bool override ] )
=== runs the shared library pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before

    include_shared( "sgsjson.dll" ); // load the JSON library DLL on Windows


include_module() [function]

== include_module( string file[, bool override ] )
=== runs the shared library pointed to by `file`, first applying file name transformation rules, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before
- the transformation rules are as follows: 1) append '.' and the lowercase platform-specific extension of shared libraries (ex. 'dll', 'so'); 2) prepend 'sgs' to file name (TODO: do we really need it? it doesn't work like that now)

    include_module( "json" ); // load the JSON library anywhere


include() [function]

== include( string file[, bool override ] )
=== the umbrella function for @include_library, @include_file, @include_module and @include_shared, attempts to call all of them in the specified order, stops on success or hard failure after any function

- this function is also available as a replicating statement 'include' (ex. 'include "fmt", "io";' works the same way as include("fmt"); include("io");)


import_cfunc() [function]

== import_cfunc( string file, string funcname )
=== retrieves the `funcname` function of the shared library `file`, returns success, as `bool`, emits a warning on failure

! Do not call 'sgscript_main' using this function! That function has different return value semantics so at best, something will work, a warning could be emitted and the worst case is that something will crash.

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)

    import_cfunc( "mydll.dll", "someSGScriptFunc" )();


sys_curfile() [function]

== sys_curfile()
=== returns the path of the file (as passed on load) that contains the currently executed code or `null` if the file cannot be determined (eval, C functions)

    // a.sgs
    print( sys_curfile() ); // prints "a.sgs"
    // b.sgs
    include "a.sgs";


sys_print() [function]

== sys_print( int code, string message )
=== passes a message to the internal messaging system (one that's commonly used to report errors and warnings)

! Different codes can be handled differently by the system. By default, SGS_ERROR code will stop execution and return to C code as soon as possible.

- `code` is the code to use to pass the message (ex. SGS_INFO, SGS_WARNING, SGS_ERROR)


sys_abort() [function]

== sys_abort()
=== stops execution and returns to C code as soon as possible

- this function is equivalent to @sgs_Abort in the C API

    sys_abort();
    print( 5 ); // this line is not reached


app_abort() [function]

== app_abort()
=== calls the abort() function of the C standard library (crashes the application)


app_exit() [function]

== app_exit( code = 0 )
=== calls the exit() function of the C standard library (exits the application)


sys_replevel() [function]

== sys_replevel([ level ])
=== returns the current reported error level and optionally sets a new one

! The effects of this function are not reverted automatically at any moment (unless implemented manually with hooks).

    old_level = sys_replevel( SGS_ERROR ); // report only errors or worse
    magic = calculate_magic(); // any warnings are never processed at this point
    sys_replevel( old_level ); // restore the old reported level


sys_stat() [function]

== sys_stat( code )
=== prints info about virtual machine state, everything is implementation-defined

- accepted codes are the same as for @sgs_Stat, which this function is equivalent to

    sys_stat( 11 ); // dumps all globals


errno() [function]

== errno( as_string = false )
=== returns the last relevant error number for the C standard library, as an integer or a string if `as_string` is set

- last relevant error number is defined by @sgs_Errno/@sgs_SetErrno C API functions

    data = io_file_read( "doesnotexist" ); // file that does not exist
    print errno(); // prints 2
    print errno(true); // prints "No such file or directory" on Windows


errno_string() [function]

== errno_string( int code )
=== returns the error string for the given code

- errno_string(errno()) is equivalent to errno(true)

    print errno_string(2); // prints "No such file or directory" on Windows


errno_value() [function]

== errno_value( string key )
=== returns the number for the error key (for "ENOENT" it would return 2)

- this function might be a bit slow considering that it currently does not use any extended lookup systems, such as hash tables

    data = io_file_read( "doesnotexist" );
    if( errno() == error_string("ENOENT") )
        println( "file does not exist" );


dumpvar() [function]

== dumpvar( var, int depth = 5 )
=== similar to @printvar() but returns the dump instead of printing it

- this function is equivalent to @sgs_DumpVar in the C API

    sys_error( SGS_INFO, "Extended variable info:\n" $ dumpvar(data) );


dumpvars() [function]

== dumpvars( ... )
=== similar to @printvars() but returns the dumps, concatenated, instead of printing them


gc_collect() [function]

== gc_collect()
=== runs the garbage collector on the virtual machine, waiting until it has finished

    a = [];
    a.push(a); // creates a circular dependency
    a = null; // a is not actually freed
    gc_collect(); // a is freed now


serialize() [function]

== serialize( var )
=== converts the variable to a byte buffer (string), containing the serialized data that can be recreated with @unserialize() or returns null and emits a warning on failure

- functions and objects without OP_SERIALIZE implemented cannot be serialized (TODO: add the serialization of SGS functions, it's already implemented in pproc)

    data = serialize({ name = "A", info = "B" });
    print data; // prints random-ish garbage
    print unserialize(data); // prints {name=A,info=B}


unserialize() [function]

== unserialize( string data )
=== recreates a variable from the buffer with serialized data or returns null and emits a warning on failure

- this function will internally call global object creation functions specified in the data, so they must be defined and the state could change in the process
- for more info on serialization in SGScript, refer to @Serialization (TODO: what could this possibly lead to?)

    @serialize example


SGS_[INFO|WARNING|ERROR] [constants]

== SGS_INFO, SGS_WARNING, SGS_ERROR are defined to the values of the C macros, respectively 100, 200 and 300


VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT] [constants]

= these constants are defined to the values of the C macros and can be compared with the values returned in @typeid() or @typeflags()


_G [superglobal]

== A hard-coded global value that points to the global dictionary. Can be used to access non-identifier globals.

    _G["$diff"] = 5; // no way to access this via usual globals


array [object]

- read-only properties
-- [int] size
-- [int] capacity
-- [cfunc] push
-- [cfunc] pop
-- [cfunc] shift
-- [cfunc] unshift
-- [cfunc] insert
-- [cfunc] erase
-- [cfunc] clear
-- [cfunc] reverse
-- [cfunc] resize
-- [cfunc] reserve
-- [cfunc] sort
-- [cfunc] sort_custom
-- [cfunc] sort_mapped
-- [cfunc] find
-- [cfunc] remove
- other features:
-- read/write integer index
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "array")


array.push [method]

== array.push( ... )
=== appends the variables passed to the end of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.push( 6, 7 ).push( 8 ); // a = [5,6,7,8]


array.pop [method]

== array.pop()
=== removes one item from the end of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5 ];
    a.pop(); // array is empty now
    a.pop(); // warning: "array is empty, cannot pop"


array.shift [method]

== array.shift()
=== removes one item from the beginning of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5, 6 ];
    a.shift(); // a = [6], returned 5


array.unshift [method]

== array.unshift( ... )
=== prepends the variables passed to the beginning of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.unshift( 6, 7 ); // a = [6,7,5] now


array.insert [method]

== array.insert( int pos, ... )
=== inserts the variables passed (all arguments after first) to the position specified in the array or emits a warning on failure (index out of bounds), returns the array for chaining

- `pos` accepts both positive and negative values, the meaning is "which value to insert before"
-- negative values are converted to positive ones by adding (<size> + 1) to them
-- beginning of array can be inserted to using position 0 or (- <size> - 1)
-- end of array can be inserted to using position <size> or -1

    a = [ 5, 7 ];
    a.insert( 1, 6 ); // inserts 6 at position 1 (before item with index 1)
    a.insert( -1, 8 ); // appends to the end of array, a = [5,6,7,8] now


array.erase [method]

== array.erase( int[, int] )
=== erases item or a range of items from the array, depending on the arguments passed or emits a warning on failure, returns the array for chaining

- both arguments have same index processing rules as @array.insert(), but with one difference - if both arguments are passed, after resolving (converting negative indices to positive ones, if there are any), first must be smaller than second

    a = [ 5, 6, 7, 8 ];
    a.erase( 1, 2 ); // erases all items between position 1 and 2, including; gives a = [5,8]
    a.erase( 0 ); // a = [8]


array.clear [method]

== array.clear()
=== erases all items from the array, returns the array for chaining

    a = [ 1, "asd", 8 ];
    a.clear(); // a = []


array.reverse [method]

== array.reverse()
=== reverses the order of items in the original array, returns the original array for chaining

    a = [ 1, 2, 3 ];
    b = a;
    a.reverse(); // a = [3,2,1]
    print( b ); // prints [3,2,1]


array.resize [method]

== array.resize( int size )
=== changes the size of the array, returns the array for chaining

- `size` must be larger than or equal to 0
- if previous size was less than passed to the method, null variables are appended
- if previous size was more than passed to the method, items are popped from the end of the array
- if size was not changed, nothing else will change

    a = [ 5, 6, 7 ];
    a.resize( 5 ); // a = [5,6,7,null,null]
    a.resize( 2 ); // a = [5,6]


array.reserve [method]

== array.reserve( int capacity )
=== reserves the space for the requested number of elements in the array, returns the array for chaining

- `capacity` must be larger than or equal to 0
- if previous capacity was less than passed to the method, capacity will be increased to the requested amount
- if previous capacity was more than or equal to what was passed to the method, nothing will change

    a = [ 5, 6, 7 ];
    a.capacity( 1 ); // nothing happens
    a.capacity( 5 ); // a.capacity = 5 and two variable additions can now happen without reallocations


array.sort [method]

== array.sort([ bool reverse ])
=== sorts the array using the @sgs_Compare C API function for comparisons, returns the array for chaining

- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    a.sort(); // a = [5,6,7,8]


array.sort_custom [method]

== array.sort_custom( callable[, bool reverse ] )
=== sorts the array using the callable for comparisons, returns the array for chaining

! This function is considerably slower than @array.sort or @array.sort_mapped so prefer those if performance matters.

- callable must return an integer, specifying the relative order of the two passed arguments: less than 0 if first variable should be placed before second, greater than 0 if first variable should be placed after second, or 0 if it doesn't matter (TODO: unsafe with big integers/FP return values! something must be done)
- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    // this code will sort numbers into odd/even ones and in ascending order
    a.sort_custom( function(a,b){return a-b+(b%2-a%2)*1000; } ); // a = [5,7,6,8]


array.sort_mapped [method]

== array.sort_mapped( array map[, bool reverse ] );
=== sorts the array by sorting the passed array and applying the index map to the first one, returns the array for chaining

- both arrays must have the same size, otherwise a warning is emitted
- all variables in the mapping array are interpreted as 'real' values
- if `reverse` is true, array is sorted in the reverse order

    a = [ 5, 6, 7, 8 ];
    b = [ 3, 1, 4, 2 ];
    a.sort_mapped( b ); // a = [6,8,5,7]


array.find [method]

== array.find( var item[, bool strict[, int from ]] )
=== attempts to find `item` in array, starting from 0 or the index passed with `from`, if it exists, using basic or strict equality comparisons (depending on `strict`), returning the index or 'null' if item was not found

- if strict comparisons are enabled, variable types are also checked for equality

    a = [ 5, 6, 7, 8 ];
    a.find( "7" ); // returns 2
    a.find( "7", true ); // returns null


array.remove [method]

== array.remove( var item[, bool strict[, bool all[, int from ]]] )
=== attepts to find and remove first or all `item` variables in array (depending on `all`), according to the rules specified in @array.find(), returning the number of removed items

    a = [ 5, 2, 6, 7, 8, 2 ];
    a.remove( "7" ); // returns 1; a = [5,2,6,8,2]
    a.remove( "6", true ); // returns 0; a remains unchanged
    a.remove( 2, false, true ); // returns 2; a = [5,6,8]


dict [object]

- features:
-- read/write string index
-- read/write string properties and integer index-via-property
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "dict")


class [object]

- read/write properties
-- [var] _super
- other features
-- read/write pass-through index
-- read/write pass-through properties (except string "_super")
-- full content dump
-- tobool = ENOTSUP, overridable via "__tobool"
-- toint = ENOTSUP, overridable via "__toint"
-- toreal = ENOTSUP, overridable via "__toreal"
-- tostring = "class", overridable via "__tostring"
-- cloning, overridable via "__clone"
-- type identification (returns the string "class", overridable via "__typeof")
-- overridable arithmetic/comparison operations
-- overridable object call
-- serialization
-- GC-safe


closure [object]

- features
-- full content dump
-- tostring = "closure"
-- type identification (returns the string "closure")
-- object call to callable, using the attached first argument
-- GC-safe


=
== STDLIB/FMT
=


fmt_pack [function]

== fmt_pack( string fmt, ... )
=== packs the given arguments using the format `fmt` and returns the byte buffer or returns null and emits a warning on failure

- the format: character command list
-- 0-9: add a digit to multiplier
-- =/</>/@: "=" sets host byte order, "<" - little endian byte order, ">" - big endian, "@" - inverted
-- +/-: "+" - unsigned integers, "-" - signed integers
-- c/w/l/q/p: integers (c - char, 1 byte, w - word, 2 bytes, l - long, 4 bytes, q - quad-word, 8 bytes, p - pointer/size, platform-specific size of 4/8 bytes, usually)
-- f/d: floating-point numbers: "f" - single precision, "d" - double precision
-- s: string, multiplier sets length instead of count, as with other items
-- x: padding byte (does not get read or written, can be used to advance the pointer)
-- space/tab/CR/LF: invisible to the parser
-- everything else resets multiplier, does nothing
- sign modifiers do nothing in fmt_pack, refer to @fmt_unpack() for their usage info

    printvar( fmt_pack( "3cf", 0, 1, 2, 3 ) ); // prints 'string [7] "\x00\x01\x02\x00\x00@@"'


fmt_unpack [function]

== fmt_unpack( string fmt, string data )
=== unpacks the byte buffer `data` using the format `fmt`, returns array of unpacked items

- unpacks c/w/l/q/p to integers, f/d to floats, s to strings
- if signed numbers are expected (as set by the "-" modifier), the sign bit of the expected type is extended to the end of the native integer type, this makes the loaded integer signed
- refer to @fmt_pack() for more info about the format

    print fmt_unpack( "3ld", fmt_pack( "3ld", 0, 1, 2, 3 ) ); // prints [0,1,2,3]


fmt_pack_count [function]

== fmt_pack_count( string fmt )
=== calculates the number of items to be expected in an unpacked array / required to make a successful fmt_pack call

- refer to @fmt_pack() for more info about the format

    print fmt_pack_count( "3ld" ); // prints 4


fmt_pack_size [function]

== fmt_pack_size( string fmt )
=== calculates the number of bytes generated by a successful fmt_pack call / required to successfully unpack data using the given format

- refer to @fmt_pack() for more info about the format

    print fmt_pack_size( "3ld" ); // prints 20


fmt_base64_encode [function]

== fmt_base64_encode( string data )
=== encodes data to produce base64 text data

- encoding is done using the following table (shortened): "A-Za-z0-9+/"

    print fmt_base64_encode( "hello world" ); // prints "aGVsbG8gd29ybGQ="


fmt_base64_decode [function]

== fmt_base64_decode( string b64text )
=== decodes base64 text data

- decoding is done using the table mentioned in @fmt_base64_encode()

    fmt_base64_decode( fmt_base64_encode( "hello world" ) ) == "hello world" // returns true


fmt_text [function]

== fmt_text( string text, ... )
=== parses all format specifiers in `text` and returns the result

- the general format of a format specifier is as follows: {fmt[size][.prec][r][p<char>]}
-- fmt: one-character output type (b-binary, o-octal, d-decimal, x/X-hexadecimal, f-floating-point, g/G-compact floating-point, e/E-scientific floating-point, s-valid string, c-always converted to string)
-- size: minimum number of characters to print
-- prec: precision of floating-point variables, string length limit
-- r: add "r" to right-pad (left-justify)
-- p<char>: add "p" and any character to set that character as the padding character (default: space/0x20)
- if anything unexpected happens, this function will emit a warning and put "#error#" in the place of a format specifier

    print fmt_text( "{d} -> {x}", 1337, 1337 ); // prints "1337 -> 539"
    print fmt_text( "null: {d}, {s}, {c}", null, null, null ); // prints "null: #error#, #error#, null" and emits two warnings for item 1 and item 2
    print fmt_text( "pi: {f10.10r} {g10r} {E10r}", M_PI, M_PI, M_PI ); // "pi: 3.1415926536 3.14159    3.141593E+000"
    TODO: more useful examples!


fmt_parser [function]

== fmt_parser( callable[, buffersize ] )
=== creates a @fmt_parser object, connected to the callable

- the callable is a function that returns at most the number of bytes requested from the stream
-- if previous request reached end, subsequent requests must return 'null'

    f = io_file( "test.txt", FILE_READ ); // TODO: this is too complex for basic features, add fmt_file_parser
    p = fmt_parser( closure( function(file,num){ if( file.eof() ) return null; return file.read( num ); }, f ) );


fmt_string_parser [function]

== fmt_string_parser( string, offset = 0 ) TODO: what about buffer size?
=== creates a @fmt_parser object, connected to a string reader, initialized to the given offset

    p = fmt_string_parser( "this is a test" );
    p.readcc( "a-z" ); // returns "this"


fmt_charcc [function]

== fmt_charcc( string char, string class )
=== checks if the first character of string `char` is included in the character class `class`

- character class is a regex-like list of specific symbols and ranges (its low and high symbols separated by "-"), optionally prepended by "^" that inverts the scope of the class

    fmt_charcc( ".", "a-zA-Z0-9" ); // returns false
    fmt_charcc( "x", "a-zA-Z0-9" ); // returns true


fmt_parser [object]

* read-only properties
 - [bool] at_end
 - [bool] stream_offset
 - [cfunc] read
 - [cfunc] getchar
 - [cfunc] readcc
 - [cfunc] skipcc
* other features:
 - GC-safe
(TODO: do we need a more feature-complete object?)


fmt_parser.read [method]

== fmt_parser.read( int num )
=== reads at most `num` bytes from stream and returns them as string

- if 0 bytes are returned, it's quite safe to assume that the function has reached the end of file but check the at_end property to be sure
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( 5 ); // returns "actio"


fmt_parser.getchar [method]

== fmt_parser.getchar( bool peek = false, bool as_int = false )
=== returns a character from stream

- if `peek` is true, stream is not advanced (next read operation will also work on the same character)
- if `as_int` is true, character is returned as integer (as one-character string otherwise)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( true ); // returns "a"
    stream.read( true, true ); // returns 97
    stream.read(); // returns "a"
    stream.read(); // returns "c"


fmt_parser.readcc [method]

== fmt_parser.readcc( string class, int num = 2^31-1 (0x7fffffff) )
=== reads and returns at most `num` bytes that match the character class `class`

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^" (TODO: is this necessary?)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.readcc( "a-z" ); // returns "what"
    stream.readcc( "^a-z" ); // returns " "


fmt_parser.skipcc [method]

== fmt_parser.skipcc( string class, int num = 2^31-1 (0x7fffffff) )
=== skips at most `num` bytes that match the character class `class` and returns the number of bytes skipped

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^" (TODO: is this necessary?)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.skipcc( "a-z" ); // returns 4
    stream.skipcc( "^a-z" ); // returns 1


=
== STDLIB/IO
=


io_setcwd [function]

== io_setcwd( string cwd )
=== sets the current working directory, returns bool/sets errno

- wraps the C library function chdir


io_getcwd [function]

== io_getcwd()
=== returns the current working directory or null, if for some reason an error occured (TODO: getcwd(NULL,0) is UB, how wide is support for expected behavior?)

- wraps the C library function getcwd/_getcwd


io_rename [function]

== io_rename( string path, string newname )
=== attempts to rename the file, returns bool/sets errno

- wraps the C library function rename, with one important difference - moving the file is not allowed, regardless of platform support (TODO: is the restriction safe and necessary?)


io_file_exists [function]

== io_file_exists( string file )
=== checks if file exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions fopen/fclose


io_dir_exists [function]

== io_dir_exists( string dir )
=== checks if directory exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions opendir,closedir where supported, _findfirst,_findclose otherwise (Windows/MSVC)


io_stat [function]

== io_stat( string fsitem )
=== returns info about the file system item `fsitem`, as dict

- the returned object contains the following properties:
-- atime: last access time
-- ctime: creation time
-- mtime: last modification time
-- type: enum (one of FST_DIR/FST_FILE/FST_UNKNOWN) TODO: do we need more?
-- size: size of item
- uses the C library function stat/_stat


io_dir_create [function]

== io_dir_create( string path, int mode = 0o777 )
=== attempts to create a directory at the specified path, with the specified access mode `mode`, returns bool/sets errno

- `mode` is ignored on Windows
- uses the C library function mkdir/_mkdir


io_dir_delete [function]

== io_dir_delete( string path )
=== attempts to delete a directory at the specified path, returns bool/sets errno

- uses the C library function rmdir/_rmdir


io_file_delete [function]

== io_file_delete( string path )
=== attempts to delete a file at the specified path, returns bool/sets errno

- uses the C library function remove


io_file_write [function]

== io_file_write( string path, string data )
=== writes the byte buffer `data` to the file pointed to by `path`, returns bool/sets errno


io_file_read [function]

== io_file_read( string path )
=== reads the byte buffer from file at `path`, returns buffer as string or null/sets errno


io_file [object]

- read-only properties
-- [int] offset
-- [int] size
-- [bool] error
-- [bool] eof
-- [cfunc] open
-- [cfunc] close
-- [cfunc] read
-- [cfunc] write
-- [cfunc] seek
-- [cfunc] flush
-- [cfunc] setbuf
- other features:
-- tostring = "file"
-- tobool = returns whether file is open or not
-- GC-safe
-- type identification (returns the string "file")


io_file.open [method]

== io_file.open( string name, int mode )
=== closes the previously open file if any, opens the file `name` for operation mode `mode`, returns bool/sets errno

- `mode` must be one of FILE_READ, FILE_WRITE or FILE_READ|FILE_WRITE
- file is always opened in binary mode

    f = io_file();
    f.open( "file" ); // returns true or false, sets errno accordingly


io_file.close [method]

== io_file.close()
=== closes the previously open file, if any, returns whether the file was open or not

    f = io_file( "file.txt" );
    f.close(); // returns true if the file existed
    f.close(); // returns false


io_file.read [method]

== io_file.read( int num )
=== reads and returns at most `num` bytes from file, sets errno


io_file.write [method]

== io_file.write( string data )
=== writes the byte buffer `data` to the file, sets errno


io_file.seek [method]

== io_file.seek( int off, int mode )
=== sets the offset in file, returns bool/sets errno

- `mode` must be one of SEEK_SET (sets as-is), SEEK_CUR (sets relative to current), SEEK_END (sets relative to end)


io_file.flush [method]

== io_file.flush()
=== flushes a buffered file, returns bool


io_file.setbuf [method]

== io_file.setbuf( int size )
=== sets the size of file buffer (0 to disable buffering), returns bool

- buffering allows to avoid committing each write immediately to disk, resulting in a performance gain, however it may introduce issues if application is expected to fail at any moment, resulting in some data not being written in such cases


io_file [function]

== io_file([ string name, int mode ])
=== creates and returns a file, optionally allowing to open it on creation

- see @io_file.open() for more info on opening the file


io_dir (directory_iterator) [object]

- features:
-- tostring = "directory_iterator"
-- iterator interface (key = whether real item, value = item name)
--- real items are all except "." and ".."
-- returns self as iterator
-- GC-safe
-- type identification (returns the string "directory_iterator")


io_dir [function]

== io_dir( string dir )
=== creates a directory iterator for the directory `dir`, sets errno, returns null and emits a warning on failure


FILE_[READ|WRITE] [constants]

== mode constants for @io_file.open() / @io_file()


SEEK_[SET|CUR|END] [constants]

== mode constants for @io_file.seek()


FST_[UNKNOWN|FILE|DIR] [constants]

== file system item type constants for @io_stat()


=
== STDLIB/MATH
=


abs() [function]

== abs( x )
=== returns the absolute value of `x`, as `real`

    abs( 2.2 ); // real (2.2)
    abs( -3.1 ); // real (3.1)


floor() [function]

== floor( x )
=== returns the largest integer that is not bigger than `x`, as `real`

    floor( 3.4 ); // real (3)
    floor( 3.8 ); // real (3)
    floor( 4.2 ); // real (4)
    floor( -3.1 ); // real (-4)


ceil() [function]

== ceil( x )
=== returns the smallest integer that is not smaller than `x`, as `real`

    ceil( 3.4 ); // real (4)
    ceil( 3.8 ); // real (4)
    ceil( 4.2 ); // real (5)
    ceil( -3.1 ); // real (-3)


round() [function]

== round( x )
=== returns the closest integer to `x`, as `real`

    round( 3.4 ); // real (3)
    round( 3.8 ); // real (4)
    round( 4.2 ); // real (4)
    round( -3.1 ); // real (-3)


pow() [function]

== pow( x, y )
=== returns `x` raised to the power `y`, as `real`

- If base (`x`) is negative and exponent (`y`) is not an integral value, or if base is zero and exponent is negative, function returns `null` and emits a warning message.

    pow( 2, 5 ); // real (32)
    pow( 9, 0.5 ); // real (3)
    pow( -1, 0.5 ); // null; Warning: pow(): mathematical error


sqrt() [function]

== sqrt( x )
=== returns the square root of `x`, as `real`

- If `x` is negative, function returns `null` and emits a warning message.

    sqrt( 16 ); // real (4)
    sqrt( -1 ); // null; Warning: sqrt(): mathematical error


log() [function]

== log( x, y )
=== returns the base-`y` logarithm of `x`, as `real`

- If `x <= 0`  or  `b <= 0`  or  `b = 1`, function returns `null` and emits a warning message.

    log( 9, 3 ); // real (2)
    log( -1, 3 ); // .. or ..
    log( 3, 0 ); // .. or ..
    log( 3, 1 ); // null; Warning: log(): mathematical error


sin() [function]

== sin( x )
=== returns the sine of angle `x` in radians, as `real`

    sin( 0 ); // real (0)
    sin( M_PI / 2 ); // real (1)
    sin( M_PI / 4 ); // real (0.707107)


cos() [function]

== cos( x )
=== returns the cosine of angle `x` in radians, as `real`

    sin( 0 ); // real (1)
    sin( M_PI ); // real (-1)
    sin( M_PI / 4 ); // real (0.707107)


tan() [function]

== tan( x )
=== returns the tangent of angle `x` in radians, as `real`

    tan( 0 ); // real (0)
    tan( 1 ); // real (1.55741)
    tan( M_PI / 4 ); // real (1)


asin() [function]

== asin( x )
=== returns the arcsine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    asin( -1 ); // real (-1.5708)
    asin( 0 ); // real (0)
    asin( 2 ); // null; Warning: asin(): mathematical error


acos() [function]

== acos( x )
=== returns the arccosine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    acos( -1 ); // real (3.14159)
    acos( 0 ); // real (1.5708)
    acos( 2 ); // null; Warning: acos(): mathematical error


atan() [function]

== atan( x )
=== returns the arctangent of `x` (angle in radians), as `real`

    atan( 0 ); // real (0)
    atan( 1 ); // real (0.785398)
    atan( 9999999 ); // real (1.5708)


atan2() [function]

== atan2( y, x )
=== returns the extended arctangent of y/x (angle in radians), as `real`

- Signs of `x` and `y` are used to determine the quadrant, thus `y` is expected to be the sine of the angle to be returned (the `y` coordinate of a point) and `x` - the cosine (the `x` coordinate).

! Due to the common requirement to use this function to determine the angle between two somewhat random points (usually from a simulation), it will not emit a warning when both arguments are 0 - it will return 0 instead.

    atan2( 0, 1 ); // real (0)
    atan2( 1, 0 ); // real (1.5708)
    atan2( -1, -1 ); // real (-2.35619)
    atan2( 0, 0 ); // real (0)


deg2rad() [function]

== deg2rad( x )
=== returns angle, converted from degrees to radians, as `real`

    deg2rad( 0 ); // real (0)
    deg2rad( 180 ); // real (3.14159)
    deg2rad( -90 ); // real (-1.5708)


rad2deg() [function]

== rad2deg( x )
=== returns angle, converted from radians to degrees, as `real`

    rad2deg( 0 ); // real (0)
    rad2deg( M_PI ); // real (180)
    rad2deg( -M_PI / 2 ); // real (-90)


M_[PI|E] [constants]

== M_PI
=== the ratio of circumference of a circle to its diameter (pi)
- the value of this constant is `3.14159265358979323846`

== M_E
=== the natural logarithmic base (e)
- the value of this constant is `2.7182818284590452354`


=
== STDLIB/OS
=


os_gettype [function]

== os_gettype()
=== returns the name of the closest known match for the operating system type, defined at library compile time

- the function can detect and return the following OSes at the moment (with the preprocessor define in braces):
-- "Windows" (_WIN32)
-- "Linux" (__linux)
-- "Unix" (__unix)
-- "POSIX" (__posix)
-- "Unknown" (..any other)


os_command [function]

== os_command( string cmd )
=== passes a command to the OS command processor, returns the integer return value

! this function can be extremely unsafe in multithreaded/incontrollable environments due to the completely undefined outcome of the call

- uses the C library function 'system'


os_getenv [function]

== os_getenv( string var )
=== returns the value for the environment variable `var` or null, if there is no such value


os_putenv [function]

== os_putenv( string cmd )
=== sets the value for the environment variable specified in command `cmd`, returns success as bool

- `cmd` has the format "<name>=<value>"


os_time [function]

== os_time( real tz = <local> )
=== returns the time in seconds, as integer, optionally from a different timezone `tz`


os_get_timezone [function]

== os_get_timezone( bool as_string = false )
=== returns the timezone set in the operating system, optionally as string in the format "(+/-)HH:MM"


os_date_string [function]

== os_date_string( string fmt, int time = os_time() )
=== returns the date/time string in the format `fmt`, optionally for a different time `time`

- the following item specifiers are supported (*-local-specific): (TODO: what about setting the locale?)
-- %a: abbreviated weekday name *
-- %A: full weekday name *
-- %b: abbreviated month name *
-- %B: full month name *
-- %c: full date/time *
-- %x: full date *
-- %X: full time *
-- %Z: timezone name/abbreviation (could be an empty string) *
-- %U: week number with first Sunday as the first day of week one *
-- %W: week number with first Monday as the first day of week one *
-- %C: year/100, as integer
-- %d: zero-padded day of the month (01-31)
-- %e: space-padded day of the month ( 1-31)
-- %F: date, shortcut of "%Y-%m-%d"
-- %H: hour in 24h format (00-23)
-- %I: hour in 12h format (01-12)
-- %j: day of the year (001-366)
-- %m: month number (01-12)
-- %M: minute (00-59)
-- %p: AM or PM
-- %R: hour/minute time, shortcut to %H:%M
-- %s: second (00-61)
-- %T: time, shortcut to %H:%M:%S
-- %u: weekday with Sunday as 0
-- %w: weekday with Monday as 1
-- %y: 2-digit year (00-99)
-- %Y: year
-- %f: file-safe full time, shortcut to %Y-%m-%d_%H-%M-%S
-- %t: the UNIX timestamp
-- %%: prints "%"
-- %<any other>: prints both characters


os_parse_time [function]

== os_parse_time( int time = os_time() )
=== returns `time` split into parts, as dict

- the returned dict contains the following properties (all are integers):
-- year (1900-????)
-- month (1-12)
-- day (1-31)
-- weekday (1-7)
-- yearday (1-366)
-- hours (0-23)
-- minutes (0-59)
-- seconds (0-61)


os_make_time [function]

== os_make_time( int sec, int min = 0, int hour = 0, int mday = 0, int mon = 0, int year = 0 )
=== returns time as UNIX timestamp, generated from the arguments, using them as hints (under-/overflows may have some unexpected behavior)


=
== STDLIB/STRING
=


string_cut() [function]

== string_cut( string str, int from[, int to[, int flags]] )
=== returns a part of string `str`, `from` and `to` being positions of the first and last character returned, respectively

- if `to` is not specified, `to` is assumed to be the position of the last character in string `str`
- if `from` or `to` are negative, they point to characters before the end of string (-1 being the last one)
- available values for `flags`:
-- `NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRICT_RANGES` - emit warnings on out of bounds `from`/`to` values instead of silently ignoring the outside characters

    string_cut( "01234567", 3, 5 ); // string [3] "345"


string_part() [function]

== string_part( string str, int from[, int len[, int flags]] )
=== returns a part of string `str`, starting at `from`, at most `len` characters

- if `len` is not specified, `len` is assumed to be the number of characters between `from` and the end of string `str`
- if `from` is negative, it points to characters before the end of string (-1 being the last one)
- if `len` is negative, the maximum length of returned string is the sum of `len` and string `str` length
- available values for `flags`:
-- `NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRICT_RANGES` - emit warnings on out of bounds `from`/`len` values instead of silently ignoring the outside characters

    string_part( "01234567", 3, 3 ); // string [3] "345"


string_reverse() [function]

== string_reverse( string str )
=== returns `str` with all the bytes in reversed order

! This function will not work correctly with multibyte-encoded strings.

    string_reverse( "noitca" ); // string [6] "action"








