
======================
== S G S c r i p t = =
======================


=
== API/INFO
=


Main types [info]

== Main data types

Return types:
- SGSRESULT [int]: output code (success = 0, failure: < 0 )
- SGSBOOL [int]: simplified output code (success = 1, failure = 0)
- SGSMIXED [int32_t] output code / value (success + value: >= 0, failure: < 0)

Virtual machine / language types:
- sgs_Bool [int32_t]: boolean value
- sgs_Int [int64_t]: integer
- sgs_Real [double]: real (floating point) value
- sgs_SizeVal [int32_t]: size type
- sgs_CFunc [int ( sgs_Context* )]: C function type
- sgs_ObjCallback [int ( sgs_Context*, sgs_VarObj*, int )]: object interface function
- sgs_Variable [struct]: the combined variable type

System types:
- sgs_Context [struct]: the virtual machine
- sgs_StackFrame [struct]: the function call info object

Interface types:
- sgs_MemFunc [void* ( void* userdata, void* ptr, size_t size )]: memory interface function
- sgs_OutputFunc [void ( void* userdata, sgs_Context* C, const void* buf, sgs_SizeVal size )]: output function
- sgs_PrintFunc [void ( void* userdata, sgs_Context* C, int code, const char* text )]: error printing function
- sgs_HookFunc [void ( void*, sgs_Context*, int )]: debug hook function


Error codes [info]

== Error codes

These are the default meanings for error codes that are honored throughout the API.

- Generated by the C API
-- SGS_SUCCESS: operation was successful
-- SGS_ENOTFND: item was not found
-- SGS_ECOMP: compile error
-- SGS_ENOTOBJ: argument was not an object
-- SGS_ENOTSUP: operation is not supported
-- SGS_EINVAL: invalid value was passed
-- SGS_EINPROC: process was interrupted

- Generated by SGScript VM
-- SGS_INFO: information about potential issues and state of the system
-- SGS_WARNING: non-fatal issues
-- SGS_ERROR: fatal issues
-- any other integer may be defined and returned by other interfaces


Variable type flags [info]

== Variable type flags

- primary flags
-- SGS_VT_NULL: (primary null flag, actually - lack of a primary flag)
-- SGS_VT_[BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: primary flags

- property flags
-- SGS_VTF_NUM: numeric type flag
-- SGS_VTF_CALL: always-callable type flag
-- SGS_VTF_REF: reference-counted type flag
-- SGS_VTF_ARRAY: array type flag
-- SGS_VTF_ARRAY_ITER: array iterator type flag
-- SGS_VTF_DICT: dict type flag

- complete flag combos
-- SGS_VTC_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT]: complete variable flags
-- SGS_VTC_[ARRAY|ARRAY_ITER|DICT]: complete specialized variable flags


Object operation types [info]

== Object operation types

- SGS_OP_END: <end of list> marker op
- SGS_OP_DESTRUCT: object destruction op (argument: whether should free child variables - 1/0)
- SGS_OP_GETINDEX: object index/property retrieval (argument: whether is a property)
- SGS_OP_SETINDEX: object index/property store (argument: whether is a property)
- SGS_OP_CONVERT: object conversion (argument: subtype)
-- subtype = SGS_VT_[BOOL|INT|REAL|STRING]: convert to boolean/integer/real/string
-- subtype = SGS_CONVOP_CLONE: create a clone of the object
-- subtype = SGS_CONVOP_TOTYPE: return the type name as string
-- subtype = SGS_TOITER: return a new iterator object for the current one
- SGS_OP_SERIALIZE: generate serialized code
- SGS_OP_DUMP: print anything informational about the variable
- SGS_OP_GCMARK: mark the object as reachable by the GC
- SGS_OP_GETNEXT: [for iterators] return the data / advance to next item
-- subtype = SGS_GETNEXT_[KEY|VALUE]: return the key/value from the iterator
-- subtype = 0: advance to next item
- SGS_OP_CALL: call the object
- SGS_OP_EXPR: perform an expression between this and another object
-- subtype = SGS_EOP_[ADD|SUB|MUL|DIV|MOD]: return A [+|-|*|/|%] B
-- subtype = SGS_EOP_COMPARE: if A < B, return -1; if A > B, return 1; otherwise return 0;
-- subtype = SGS_EOP_NEGATE: return the current value, negated


Interaction with the native environment [info]

== Interaction with the native environment

=== Memory allocation
- sgs_MemFunc must be specified in creation of the scripting engine context
- sgs_MemFunc (re)allocates and frees memory
- unlike realloc, if size = 0, this function must return NULL
- sgs_DefaultMemFunc is the sample implementation
- the expected behavior is same as for @sgs_Memory()


=
== API/BASIC
=


sgs_CreateEngine [function alias]

== sgs_Context* sgs_CreateEngine()
=== returns a new scripting engine context

- alias to `sgs_CreateEngineExt( sgs_DefaultMemFunc, NULL )`


sgs_CreateEngineExt [function]

== sgs_Context* sgs_CreateEngineExt( sgs_MemFunc memfunc, void* mfuserdata )
=== returns a new scripting engine context, attached to the specified allocator


sgs_DestroyEngine [function]

== sgs_DestroyEngine( sgs_Context* C )
=== destroys the passed context and frees all memory associated to it


sgs_ExecString [function alias]

== SGSRESULT sgs_ExecString( sgs_Context* C, const char* str )
=== compiles and executes a string of text

- leaves the stack the same as it was before the call
- alias to `sgs_ExecBuffer( C, str, SGS_STRINGLENGTHFUNC( str ) )`
- theoretically bytecode is supported but it will most probably be trimmed by the string length function, unless a different string termination mark is used, and a different string length function to detect it is set

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_ExecBuffer [function alias]

== SGSRESULT sgs_ExecBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size )
=== compiles and executes a buffer of text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalBuffer( C, buf, size, NULL )`

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalString [function alias]

== SGSRESULT sgs_EvalString( sgs_Context* C, const char* str, int* rvc )
=== compiles and executes a string of text, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call
- alias to sgs_EvalBuffer( C, str, SGS_STRINGLENGTHFUNC( str ), rvc )

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalBuffer [function]

== SGSRESULT sgs_EvalBuffer( sgs_Context* C, const char* buf, sgs_SizeVal size, int* rvc )
=== compiles and executes a buffer of text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_ExecFile [function alias]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename )
=== compiles and executes a file containing script text or bytecode

- leaves the stack the same as it was before the call
- alias to `sgs_EvalFile( C, filename, NULL )`

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_EvalFile [function]

== SGSRESULT sgs_ExecFile( sgs_Context* C, const char* filename, int* rvc )
=== compiles and executes a file containing script text or bytecode, optionally leaving the return values on stack and returning the number of values via `rvc`

- if `rvc` is not set (NULL), return values are removed - the stack is the same as it was before the call

=== error codes
- SGS_ECOMP: compiler error
- SGS_EINVAL: passed data was not recognized


sgs_LoadLib_[Fmt|IO|Math|OS|String] [functions]

== SGSRESULT sgs_LoadLib_Fmt( sgs_Context* C )
== SGSRESULT sgs_LoadLib_IO( sgs_Context* C )
== SGSRESULT sgs_LoadLib_Math( sgs_Context* C )
== SGSRESULT sgs_LoadLib_OS( sgs_Context* C )
== SGSRESULT sgs_LoadLib_String( sgs_Context* C )
=== loads the library into the specified context

- it is generally unnecessary to check for these error codes

=== error codes
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


sgs_Reg[Func|Int|Real]Const [struct]

== sgs_RegFuncConst { char* name; sgs_CFunc value; }
== sgs_RegIntConst { char* name; sgs_Int value; }
== sgs_RegRealConst { char* name; sgs_Real value; }
=== a pair of null-terminated string and a scripting engine value type


sgs_Reg[Func|Int|Real]Consts [function]

== SGSRESULT sgs_RegFuncConsts( sgs_Context* C, const sgs_RegFuncConst* list, int size )
== SGSRESULT sgs_RegIntConsts( sgs_Context* C, const sgs_RegIntConst* list, int size )
== SGSRESULT sgs_RegRealConsts( sgs_Context* C, const sgs_RegRealConst* list, int size )
=== loads the specified list of constants in the context

- the end of list can be specified in two ways
-- set the size to `sizeof(list)/sizeof(list[0])`
-- set the size to -1 and end the list with `SGS_RC_END()`
-- using both at the same time should be reserved to special cases only

=== error codes
- SGS_E****: first error encountered (operation stopped somewhere in the middle)


=
== API/DATA
=


sgs_Push[Null|Bool|Int|Real|StringBuf|String|CFunction|Object|ObjectIPA|Variable] [functions]

== void sgs_PushNull( sgs_Context* C )
== void sgs_PushBool( sgs_Context* C, sgs_Bool value )
== void sgs_PushInt( sgs_Context* C, sgs_Int value )
== void sgs_PushReal( sgs_Context* C, sgs_Real value )
== void sgs_PushStringBuf( sgs_Context* C, const char* str, sgs_SizeVal size )
== void sgs_PushString( sgs_Context* C, const char* str )
== void sgs_PushCFunction( sgs_Context* C, sgs_CFunc func )
== void sgs_PushObject( sgs_Context* C, void* data, void** iface )
== void* sgs_PushObjectIPA( sgs_Context* C, sgs_SizeVal added, void** iface )
== void sgs_PushVariable( sgs_Context* C, sgs_Variable* var )
=== pushes the data on the stack, as a new entry, appended to the end

- sgs_Bool is transformed to 0/1 before pushing, everything else is unchanged
- sgs_PushStringBuf( C, NULL, size ) would allocate an uninitialized buffer
-- it is accessible immediately by @sgs_GetString[Ptr|Size]( C, -1 )
- sgs_PushObjectIPA stands for "push object, allocate memory in-place"
-- it means that the `added` memory space will be appended to the end of object allocation
-- this allows to allocate all object data for most objects with just one allocation, instead of two
-- the allocated memory will be returned and also available via sgs_GetObjectData( C, -1 )->data
- sgs_PushVariable will increment the reference count of strings, SGS functions and objects
- these functions do not throw an error when the stack is full since there is no way to handle that


sgs_Pop [function]

== SGSRESULT sgs_Pop( sgs_Context* C, int count )
=== pops `count` variables off the current frame of the stack

=== error codes
- SGS_EINVAL: `count` was bigger than the number of items in the current stack frame or `count` is less than 0


sgs_PopSkip [function]

== SGSRESULT sgs_PopSkip( sgs_Context* C, int count, int skip )
=== pops `count` variables off the current frame of the stack, skipping the last `skip` elements

=== error codes
- SGS_EINVAL: `count+skip` was bigger than the number of items in the current stack frame or `count` is less than 0 or `skip` is less than 0


sgs_InsertVariable [function]

== SGSRESULT sgs_InsertVariable( sgs_Context* C, int pos, sgs_Variable* var )
=== inserts a variable `var` at a given index `pos` of the current stack frame, increasing its reference count

=== error codes
- SGS_EBOUNDS: index out of bounds


sgs_PushArray [function]

== SGSRESULT sgs_PushArray( sgs_Context* C, sgs_SizeVal numitems )
=== creates an array from `numitems` last items on the stack, pops those items and pushes the array

=== error codes
- SGS_EINVAL: more items are selected than exist in the current stack frame


sgs_PushDict [function]

== SGSRESULT sgs_PushDict( sgs_Context* C, sgs_SizeVal numitems )
=== creates a dict from `numitems` last items on the stack, pops those items and pushes the dict

- `numitems` can be even or 0, since all odd arguments are keys and all even arguments are values

=== error codes
- SGS_EINVAL: more items are selected than exist in the current stack frame or `numitems` wasn't even or 0


sgs_PushItem [function]

== SGSRESULT sgs_PushItem( sgs_Context* C, int item )
=== copy an item from the current stack frame and append it to the end of the stack

=== error codes
- SGS_EBOUNDS: index out of bounds


sgs_StoreItem [function]

== SGSRESULT sgs_StoreItem( sgs_Context* C, int item )
=== copy last item in current stack frame to index `item` and pop it

- `item` refers to a position after the pop operation, therefore -1 means one element before the last etc.

=== error codes
- SGS_EBOUNDS: index out of bounds


sgs_PushProperty [function]

== SGSRESULT sgs_PushProperty( sgs_Context* C, const char* name )
=== load and push the property of the topmost item in the current stack frame

=== error codes
- SGS_EINPROC: current stack frame is empty
- SGS_ENOTFND: property was not found
- other codes may appear if returned by custom objects


sgs_StoreProperty [function]

== SGSRESULT sgs_StoreProperty( sgs_Context* C, int obj, const char* name )
=== copy and pop the topmost item of the current stack frame to the property `name` of variable `obj`

=== error codes
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame
- SGS_ENOTFND: property was not found
- other codes may appear if returned by custom objects


sgs_PushNumIndex [function]

== SGSRESULT sgs_PushNumIndex( sgs_Context* C, int obj, sgs_Int idx )
=== load and push the integer index `idx` of the variable `obj`

=== error codes:
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- other codes may appear if returned by custom objects


sgs_StoreNumIndex [function]

== SGSRESULT sgs_StoreNumIndex( sgs_Context* C, int obj, sgs_Int idx )
=== copy and pop the topmost item of the current stack to the integer index `idx` of variable `obj`

=== error codes
- SGS_EBOUNDS: `obj` was not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- other codes may appear if returned by custom objects


sgs_PushIndexExt [function]

== SGSRESULT sgs_PushIndexExt( sgs_Context* C, int obj, int idx, int prop )
=== load and push the indexed item/property (if `prop` is nonzero) `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: property/index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_PushIndex [function alias]

== SGSRESULT sgs_PushIndex( sgs_Context* C, int obj, int idx )
=== load and push the indexed item `idx` of the item `obj` in the current stack frame

- alias of `sgs_PushIndexExt( C, obj, idx, 0 )`

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_PushIndexP [function]

== SGSRESULT sgs_PushIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )
=== load and push the indexed item `idx` of the item `obj`

=== error codes
- SGS_EBOUNDS: array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_StoreIndexExt [function]

== SGSRESULT sgs_StoreIndexExt( sgs_Context* C, int obj, int idx, int prop )
=== copy and pop the topmost stack item to the indexed item/property (if `prop` is nonzero) `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: property/index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_StoreIndex [function alias]

== SGSRESULT sgs_StoreIndex( sgs_Context* C, int obj, int idx )
=== copy and pop the topmost stack item to the indexed item `idx` of the item `obj` in the current stack frame

=== error codes
- SGS_EBOUNDS: `obj` or `idx` were not pointing inside the current stack frame / array index out of bounds
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_StoreIndexP [function]

== SGSRESULT sgs_StoreIndexP( sgs_Context* C, sgs_Variable* obj, sgs_Variable* idx )
=== copy and pop the topmost stack item to the indexed item `idx` of the item `obj`

=== error codes
- SGS_EBOUNDS: array index out of bounds
- SGS_EINPROC: current stack frame is empty
- SGS_ENOTFND: index was not found
- SGS_EINVAL: index is not of string or integer type
- other codes may appear if returned by custom objects


sgs_PushGlobal [function]

== SGSRESULT sgs_PushGlobal( sgs_Context* C, const char* name )
=== push the global variable `name` on the stack

=== error codes
- SGS_ENOTFND: variable was not found


sgs_StoreGlobal [function]

== SGSRESULT sgs_StoreGlobal( sgs_Context* C, const char* name )
=== copy and pop the topmost stack item to the global variable `name`

- _G is the environment table (a superglobal, list of global variable names and values)

=== error codes
- SGS_EINPROC: current stack frame was empty
- SGS_ENOTSUP: _G only accepts dict values


sgs_PushPath [function]

== sgs_PushPath( sgs_Context* C, int item, const char* path, ... )
=== push the variable specified by starting point `item` and traversal path `path`

! The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.

- the syntax of `path`:
-- a list of letters, specifying a sub-variable to request (o,p,s,i,k,n)

==== table of accepted letters
---------------------------------------------------------------------------------------
! letter ! property? ! variable arguments ! virtual machine access mode / description !
|    o   |    yes    |  SizeVal           |   integer property                        |
|    p   |    yes    |  C string          |   string property                         |
|    s   |    yes    |  SizeVal, buffer   |   special string property                 |
|    i   |    no     |  SizeVal           |   integer index                           |
|    k   |    no     |  C string          |   string index                            |
|    n   |    no     |  SizeVal, buffer   |   special string index                    |
---------------------------------------------------------------------------------------
- legend:
-- SizeVal: sgs_SizeVal / int32_t
-- C string: null-terminated char* string
-- buffer: char* byte array, size is specified in the previous argument
-- property?: if yes, property access is used (object.property), otherwise index access is used (object[index])

=== error codes
- SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
- other errors, as returned by @sgs_PushIndexExt()


sgs_StorePath [function]

== sgs_StorePath( sgs_Context* C, int item, const char* path, ... )
=== copy and pop the topmost item on stack to variable specified by starting point `item` and traversal path `path`

! The safety of this function is similar to that of the printf family of functions. Be explicit in what types you pass to the variable argument list to avoid errors.

- the syntax of `path` is the same as with @sgs_PushPath()
- the last item on the path (or in the case of an empty path, the starting point) is accessed with a store operation, the rest - with a push operation

=== error codes
- SGS_EINVAL: invalid symbol found in path / corresponding variable arguments had an invalid value
- SGS_EINPROC: current stack frame is empty
- other errors, as returned by @sgs_PushIndexExt() or @sgs_StoreIndexExt()


sgs_ArgErrorExt [function]

== int sgs_ArgErrorExt( SGS_CTX, int argid, int method, const char* expect, const char* expfx )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement


sgs_ArgError [function]

== int sgs_ArgError( sgs_Context* C, int argid, int expect, int is_strict )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement


sgs_[FuncArgError|MethodArgError] [function aliases]

== int sgs_FuncArgError( sgs_Context* C, int argid, int expect, int is_strict )
== int sgs_MethodArgError( sgs_Context* C, int argid, int expect, int is_strict )
=== prints the argument type mismatch error

- always returns 0 so it can be used to return and print an error in the same statement
- alias to `sgs_ArgError( C, argid, Func/Method => 0/1, expect, is_strict )`


sgs_LoadArgsExt [function]

== SGSMIXED sgs_LoadArgsExt( sgs_Context* C, int from, const char* cmd, ... )
=== parse the stack items and retrieve their data according to `cmd`, starting from item `from`

- for anything function requires, pass the value; for anything it returns - the pointer to the value
- `cmd` is a string consisting of one-character commands
- the commands are grouped into two kinds: control commands and parsing commands
- function returns whether all required arguments have been parsed successfully
-- thus, if function returns < 1, state of outputs is somewhat unknown unless filled with defaults
-- it is guaranteed that all arguments will be parsed from first (specified) forward, not in any other way

! unlike sgs_LoadArgs, it returns `SGSMIXED` and must be checked differently ("ret.val. > 0", if same output needed)

==== control commands
- `?` -- only check, do not write the result and do not require a pointer to write the data to
- `!` -- enable strict parsing for the next item (requires exactly the type specified
- `-`,`+` -- enable (-) or disable (+) treating integers as signed (default = true)
- `|` -- mark the point where required arguments end and optional arguments begin
- `#` -- do range checking on integer arguments (min/max of the required types)
- `^` -- clamp the argument to the range of the required type
- `~` -- ignore ranges and chop out-of-range integers (default)
- `<` -- move argument pointer 1 item back (cannot move it before 0)
- `>` -- move argument pointer 1 item forward
- `@` -- specify that this is a method (argument 0 = 'this'; shifts argument indices on error printing by -1)
- `.` -- specify the end of argument list (how many arguments are expected)

==== parsing commands
- `n` -- check for `null` (returns SGSBOOL = 1, always strict)
- `b` -- check for `bool` (returns SGSBOOL)
- `c` -- check for `int` (returns int8_t or uint8_t, depending on sign settings, may check ranges)
- `w` -- check for `int` (returns int16_t or uint16_t, depending on sign settings, may check ranges)
- `l` -- check for `int` (returns int32_t or uint32_t, depending on sign settings, may check ranges)
- `q` -- check for `int` (returns int64_t or uint64_t, depending on sign settings, may check ranges)
- `i` -- check for `int` (returns sgs_Int, may check ranges)
- `f` -- check for `real` (returns float)
- `d` -- check for `real` (returns double)
- `r` -- check for `real` (returns sgs_Real)
- `s` -- check for `string` (returns char*)
- `m` -- check for `string` (returns char* string and sgs_SizeVal size)
- `p` -- check for `func/cfunc/object with SGS_OP_CALL` (callables) (returns SGSBOOL = 1)
- `a` -- check for `array` (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
- `t` -- check for `dict` (returns sgs_SizeVal size, use -1 as starting value to check optional arguments)
- `o` -- check for `object` (requires void** interface, returns sgs_VarObj* data)
- `v` -- check for any (non-null if strict, returns sgs_Variable data)
- `x` -- call a custom checking function (requires sgs_ArgCheckFunc, everything else depends on function)

=== error codes
- SGS_EINVAL: error in `cmd` (wrong character/argument pointer moved before 0)


sgs_LoadArgs [function alias]

== SGSBOOL sgs_LoadArgs( sgs_Context* C, const char* cmd, ... )
=== parse the stack items and retrieve their data according to `cmd`, starting from item 0

! unlike sgs_LoadArgsExt, it returns `bool` - whether all required arguments have been successfully parsed

- for more info on syntax and usage, refer to @sgs_LoadArgsExt
- alias to `sgs_LoadArgsExt( C, 0, cmd, ... )>0`


=
== API/OPERATIONS
=


sgs_FCall [function]

== SGSRESULT sgs_FCall( sgs_Context* C, int args, int expect, int gotthis )
=== call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack

- `args`: the primary variables to be passed to the function, in the same order they are in the stack
- `expect`: the number of variables to be left after a successful call
- `gotthis`: whether the function is a method and an additional argument needs to be passed as the 'this' value before others

After a successful call, all arguments and the function will be popped off the stack and the expected number of variables will appear in their place. If the underlying callable does not return enough arguments, 'null' variables will be pushed instead. If the number of returned values is bigger than expected, only the first expected return values will stay on the stack.

- expected stack structure:
-- (if gotthis != 0) [this]
-- [argument] x `args`
-- [callable]

- a callable is one of the following:
-- SGS function
-- C function
-- object with SGS_OP_CALL interface function defined

! Stack is returned to the expected state only if the return value is equal to SGS_SUCCESS or SGS_EINPROC. Otherwise, it's left exactly as it was before the call.

=== error codes
- SGS_EINPROC: topmost item on stack was not callable
- SGS_EINVAL: not enough values in current stack frame (must have at least `args + (gotthis?1:0) + 1`)


sgs_[Call|ThisCall] [function aliases]

== SGSRESULT sgs_Call( sgs_Context* C, int args, int expect )
== SGSRESULT sgs_ThisCall( sgs_Context* C, int args, int expect )
=== call the topmost variable on stack with the arguments before it, returning the expected number of variables on stack

- aliases to @sgs_FCall(), for the first `gotthis = 0`, for the second `gotthis = 1`.


sgs_GlobalCall [function]

== SGSRESULT sgs_GlobalCall( sgs_Context* C, const char* name, int args, int expect )
=== call the global variable `name` as a function

- combination of @sgs_PushGlobal() and @sgs_Call()


sgs_TypeOf [function]

== SGSRESULT sgs_TypeOf( sgs_Context* C )
=== return the type name string of topmost variable in current stack frame

- if the object does not support the specific part of the conversion interface function, a string of format "object (%p)" is returned to ensure expected type name comparison capabilities

=== error codes
- SGS_EINPROC: current stack frame was empty


sgs_DumpVar [function]

== SGSRESULT sgs_DumpVar( sgs_Context* C, int maxdepth )
=== convert the topmost variable of current stack frame to a highly informative string that should display the contents of the variable, up to `maxdepth` depth

- if object does not have the SGS_OP_DUMP interface function implemented, only its pointer in memory and reference count are displayed

=== error codes
- SGS_EINPROC: current stack frame was empty
- SGS_EINVAL: invalid base variable type found in variable (not really expected to happen unless custom variable creation is done)


sgs_GCExecute [function]

== SGSRESULT sgs_GCExecute( sgs_Context* C )
=== call the garbage collector on the VM

- this procedure may take some time if the object graph is big
- during the procedure, the SGS_OP_GCMARK interface functions of objects are invoked for the objects visible from entry points (like stack and global table)
- aborting of the procedure (via error codes) would lead the system into an unrecoverable state (TODO: is that really necessary?)

=== error codes
- any code can be returned by SGS_OP_GCMARK and SGS_OP_DESTRUCT functions, doing so would abort the process if the code is not either SGS_SUCCESS or SGS_ENOTFND


sgs_PadString [function]

== SGSRESULT sgs_PadString( sgs_Context* C )
=== append two spaces after every newline in the topmost variable of current stack frame

=== error codes
- SGS_EINPROC: current stack frame is empty
- SGS_EINVAL: topmost variable is not a string


sgs_StringConcat [function]

== SGSRESULT sgs_StringConcat( sgs_Context* C )
=== concatenate the two topmost string variables in the current stack frame

=== error codes
- SGS_EINPROC: not enough variables were found in the current stack frame


sgs_StringMultiConcat [function]

== SGSRESULT sgs_StringMultiConcat( sgs_Context* C, int args )
=== concatenate the `args` number of topmost string variables in the current stack frame

=== error codes
- SGS_EINVAL: not enough (less than `args`) variables were found in the current stack frame


sgs_CloneItem [function]

== SGSRESULT sgs_CloneItem( sgs_Context* C, int item )
=== push a copy of the specified stack item

! Even though operations with functions and strings succeed, functions and strings are not actually cloned since they are immutable.

=== error codes
- SGS_EBOUNDS: stack item index was out of bounds
- SGS_ENOTFND: the object does not support cloning


sgs_Serialize [function]

== SGSRESULT sgs_Serialize( sgs_Context* C )
=== serialize the topmost variable of the current stack frame (convert to a binary recreation instruction stream)

- the following variable types can be serialized:
-- null, bool, int, real, string, func (SGS function)
-- objects with the SGS_OP_SERIALIZE interface function defined

- serialized data has the following format:
-- a list of 'P' or 'C' commands
-- 'P' (push) command: byte - variable type; variable data
--- variable data: nothing for null, byte for bool, int64 for int, double for real, int32 + char[] for string
-- 'C' (call) command: int32 - number of arguments; byte - function name size; char[] - function name

=== error codes
- SGS_EBOUNDS: current stack frame was empty
- SGS_EINVAL: an unserializable topmost variable was found (function)
- SGS_EINPROC: unknown memory error


sgs_SerializeObject [function]

== SGSRESULT sgs_SerializeObject( sgs_Context* C, int args, const char* func )
=== write the serialized code for an object's unserializing function

=== error codes
- SGS_EINVAL: function name was too long (255 characters or more)
- SGS_EINPROC: function was used outside serialization interface function


sgs_Unserialize [function]

== SGSRESULT sgs_Unserialize( sgs_Context* C )
=== unserialize the topmost string variable of the current stack frame (run the binary recreation instruction stream)

! Be mindful of the data sources you use - calls to any global function can be placed in the instruction stream. (TODO: need the ability to change global variable lists completely)


sgs_CompareF [function]

== sgs_Real sgs_CompareF( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return the difference between variables, as `real`


sgs_Compare [function alias]

== int sgs_Compare( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return the difference between variables, as int -1/0/1

- alias to @sgs_CompareF() + conversion (if result < 0, return -1; if result > 0, return 1; otherwise return 0)


sgs_EqualTypes [function]

== SGSBOOL sgs_EqualTypes( sgs_Context* C, sgs_Variable* v1, sgs_Variable* v2 )
=== return if types of both variables are exactly equal

- both type variables and interface pointers (only if both variables are objects) are checked for equality


=
== API/CONV-RET
=


sgs_[GetBool|GetInt|GetReal] [functions]

== sgs_Bool sgs_GetBool( sgs_Context* C, int item )
== sgs_Int sgs_GetInt( sgs_Context* C, int item )
== sgs_Real sgs_GetReal( sgs_Context* C, int item )
=== return an item from the current stack frame, converted to the specified type

- if `item` is out of bounds, 0 is returned


sgs_[ToBool|ToInt|ToReal] [functions]

== sgs_Bool sgs_ToBool( sgs_Context* C, int item )
== sgs_Int sgs_ToInt( sgs_Context* C, int item )
== sgs_Real sgs_ToReal( sgs_Context* C, int item )
=== return an item from the current stack frame, converted in-place to the specified type

- in-place conversion means that if the function succeeds, the item in the stack might have a different type, most likely the requested type


sgs_[ToStringBuf|ToStringBufFast] [functions]

== char* sgs_ToStringBuf( sgs_Context* C, int item, sgs_SizeVal* outsize )
== char* sgs_ToStringBufFast( sgs_Context* C, int item, sgs_SizeVal* outsize )
=== return an item from the current stack frame, converted in-place to string

- if `item` is out of bounds or conversion fails, NULL is returned
- the 'fast' version uses type name conversion on object, instead of string conversion - this is to avoid recursion while generating a short description about object contents
- length of string is returned to the value that `outsize` points to


sgs_[ToString|ToStringFast] [function aliases]

== char* sgs_ToString( sgs_Context* C, int item )
== char* sgs_ToStringFast( sgs_Context* C, int item )
=== return an item from the current stack frame, converted in-place to string

- aliases of @sgs_ToStringBuf() and @sgs_ToStringBufFast() with the third argument set to NULL


sgs_Convert [function]

== SGSRESULT sgs_Convert( sgs_Context* C, int item, int type )
=== convert an item from the current stack frame to the specified base type

- `type` expects one of the SGS_VT_* constants

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_ENOTSUP: object does not support the specific conversion
- SGS_ENOTFND: object does not support conversions


sgs_IsObject [function]

== SGSBOOL sgs_IsObject( sgs_Context* C, int item, void** iface )
=== returns whether the specified stack item `item` is an object with the interface pointer `iface`

- if `item` is out of bounds or not an object or doesn't have the specified interface, 0 is returned


sgs_IsCallable [function]

== SGSBOOL sgs_IsCallable( sgs_Context* C, int item )
=== returns whether the specified stack item `item` is callable

- callable variables are either SGS functions or C functions or objects with the SGS_OP_CALL interface implemented
- if `item` is out of bounds, 0 is returned


sgs_IsNumericString [function]

== SGSBOOL sgs_IsNumericString( const char* str, sgs_SizeVal size )
=== checks if the string is convertible to an integer/real

- TODO: link to parsing rules


sgs_[ParseBool|ParseInt|ParseReal|ParseString] [functions]

== SGSBOOL sgs_ParseBool( sgs_Context* C, int item, sgs_Bool* out )
== SGSBOOL sgs_ParseInt( sgs_Context* C, int item, sgs_Int* out )
== SGSBOOL sgs_ParseReal( sgs_Context* C, int item, sgs_Real* out )
== SGSBOOL sgs_ParseString( sgs_Context* C, int item, char** out, sgs_SizeVal* size )
=== attempts to parse the specified item of the current stack frame, returning whether parsing was successful

- the parsing rules:
-- if `item` is out of bounds, fail
-- if item has the type `null`, `func` or `cfunc`, fail
-- if item is of `string` type and `bool` is requested, fail
-- if item is of `string` type and `int`/`real` is requested, try to convert
-- if item is of `object` type, success of conversion depends on implementation of the object interface and the rules of sgs_GetBool/sgs_GetInt/sgs_GetReal/sgs_ToStringBuf
-- everything else succeeds


sgs_PushIterator [function]

== SGSRESULT sgs_PushIterator( sgs_Context* C, int item )
=== create an iterator from the specified item of the current stack frame

- iterators are objects that enable sequential, ordered traversal of object contents, allowing to read up to 2 variables at each position: the key and the value
- iterator starts at the pre-first position, so nothing can be read before the initial state

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_ENOTSUP: variable type does not support iterators (only objects support them)
- SGS_ENOTFND: object type does not support iterators (iterator conversion request failed)
- any other code can be returned by the object


sgs_IterAdvance [function]

== SGSMIXED sgs_IterAdvance( sgs_Context* C, int item )
=== advance the iterator to the next position, returning if the current position is still in range or an error code on failure

- this is the way it's expected to be usually called: `while( sgs_IterAdvance( C, item ) > 0 ){ ... sgs_IterPushData ... }`

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_EINVAL: iterated object changed in a way that iterator does not support (currently a size equality test) (TODO: what about any other structural changes? can we have a revision number?)
- SGS_EINPROC: internal failure in the object interface


sgs_IterPushData [function]

== SGSRESULT sgs_IterPushData( sgs_Context* C, int item, int key, int value )
=== load and push the data associated with the current position

- `key` and `value` are booleans that specify if the respective value should be returned
- first the key is pushed, then the value
- if neither `key` nor `value` are expected, the call succeeds and doesn't push anything

=== error codes
- SGS_EBOUNDS: index out of bounds
- SGS_EINVAL: iterated object changed in a way that iterator does not support
- SGS_EINPROC: internal failure in the object interface


sgs_ArraySize [function]

== SGSMIXED sgs_ArraySize( sgs_Context* C, int item )
=== check if the specified stack item is an array and return its size or error code on failure

=== error codes
- SGS_EINVAL: index out of bounds / variable was not an array


=
== API/EXT
=


sgs_StackSize [function]

== int sgs_StackSize( sgs_Context* C )
=== return the size of the current stack frame


sgs_IsValidIndex [function]

== SGSBOOL sgs_IsValidIndex( sgs_Context* C, int item )
=== return whether the specified stack index points to an item in the current stack frame

- both positive (first = 0) and negative (last = -1) indices are supported


sgs_GetStackItem [function]

== SGSBOOL sgs_GetStackItem( sgs_Context* C, int item, sgs_Variable* out )
=== write the data of the specified stack variable if the index is valid

- function returns whether the stack index was valid


sgs_ItemType [function]

== int sgs_ItemType( sgs_Context* C, int item )
=== return the base type (first 8 bits, mask 0xff) of the specified stack item

- return value will be equal to one of the SGS_VT_* macro
- if index is invalid, return value will be 0


sgs_ItemTypeExt [function]

== int sgs_ItemTypeExt( sgs_Context* C, int item )
=== return the full type of the specified stack item

- return value expected to be equal to one of the SGS_VTC_* macro
- if index is invalid, return value will be 0


sgs_Method [function]

== SGSBOOL sgs_Method( sgs_Context* C )
=== unlock the 'this' variable, return if the function was called as a method (and thus variable was unlocked)

- method calls look like this: "object.method(...)"


sgs_Acquire [function]

== void sgs_Acquire( sgs_Context* C, sgs_Variable* var )
=== increment the reference count of the variable (if it counts references)


sgs_Release [function]

== void sgs_Release( sgs_Context* C, sgs_Variable* var )
=== decrement and possibly deallocate the reference count of the variable (if it counts references)


sgs_ReleaseOwned [function]

== void sgs_ReleaseOwned( sgs_Context* C, sgs_Variable* var, int dco )
=== decrement and possibly deallocate the reference count of the variable (if it counts references), depending on `dco`

- `dco` stands for "destroy child objects", which essentially means that if it's zero and the variable is an object, it prevents the object from being destroyed
- expected to be called in destructors of objects may that contain reference-counted variables, using the parameter passed in the callback
- the child objects need to be preserved in exactly once case: the garbage collector destruction phase - when all objects are scheduled for deletion, it is important to avoid destroying them twice


sgs_GCMark [function]

== SGSRESULT sgs_GCMark( sgs_Context* C, sgs_Variable* var )
=== mark the specified variable as reachable for the garbage collector

- to be called in the SGS_OP_GCMARK object callback


sgs_GetStringPtr [function]

== char* sgs_GetStringPtr( sgs_Context* C, int item )
=== return the string data pointer of the specified stack item, using BreakIf to validate the call

- if item is out of bounds or not a string, one of the BreakIf macros will go off and stop the action


sgs_GetStringSize [function]

== sgs_SizeVal sgs_GetStringSize( sgs_Context* C, int item )
=== return the string size of the specified stack item, using BreakIf to validate the call

- if item is out of bounds or not a string, one of the BreakIf macros will go off and stop the action


sgs_GetObjectData [function]

== sgs_VarObj* sgs_GetObjectData( sgs_Context* C, int item )
=== return the object data pointer of the specified stack item, using BreakIf to validate the call

- if item is out of bounds or not an object, one of the BreakIf macros will go off and stop the action


=
== API/ENV
=


sgs_SetOutputFunc [function]

== void sgs_SetOutputFunc( sgs_Context* C, sgs_OutputFunc func, void* userdata )
=== sets the function used in 'print' function

- default implementation copies data to FILE* stream, specified in userdata, it can be found in sgs_ctx.c


sgs_Write [function]

== void sgs_Write( sgs_Context* C, const void* ptr, sgs_SizeVal size )
=== passes the specified data to the output function

- the default output function prints the data to the specified FILE* stream (stdout by default)


sgs_WriteStr [function alias]

== void sgs_Write( sgs_Context* C, const char* str )
=== passes the specified string to the output function

- alias to `sgs_Write( C, str, SGS_STRINGLENGTHFUNC( str ) )`


sgs_Writef [function]

== void sgs_Writef( sgs_Context* C, const char* what, ... )
=== passes the arguments through a vsprintf-like function to expand the data and passes it to the specified output function

- printf rules apply here


sgs_SetPrintFunc [function]

== void sgs_SetPrintFunc( sgs_Context* C, sgs_PrintFunc func, void* userdata )
=== sets the function that handles and prints the error that has occured, while still being physically in that context

- both subtypes of the default printing function can be set by passing these flags for `func` and a FILE* pointer for `userdata`:
-- 'SGSPRINTFN_DEFAULT' - default behavior (write stack frame, write error, abort on SGS_ERROR)
-- 'SGSPRINTFN_DEFAULT_NOABORT' - default behavior without the abort-on-errors feature
- default implementation writes error and stack trace to FILE* stream, specified in userdata, it can be found in sgs_ctx.c


sgs_Printf [function]

== int sgs_Printf( sgs_Context* C, int type, const char* what, ... )
=== prepares and prints the error specified

- `type` is the output code (SGS_WARNING, SGS_ERROR etc.)
- `what` is the error text
-- additional function name prefix can be specified with @sgs_FuncName or the SGSFN/SGSBASEFN macros
- `what`, the function name prefix (if set) and the variable arguments are passed to a vsprintf-like function so printf syntax rules apply
- function always returns 0 to be compatible with most error handling cases in C functions: "return sgs_Printf( ... );"


sgs_HasFuncName [function]

== int sgs_HasFuncName( sgs_Context* C )
=== checks if the currently executed function (last stack frame) has a name literal set


sgs_FuncName [function]

== void sgs_FuncName( sgs_Context* C, const char* fnliteral )
=== sets the function name string for the currently executed function (last stack frame)

- the argument is expected to stay alive for the duration of the function call
-- this makes string literals safe for the call, everything else should be avoided


SGSFN [function alias]

== void SGSFN( const char* fnliteral )
=== sets the function name string, more info at @sgs_FuncName

- alias for `sgs_FuncName( <implicit> C, fnliteral )`


SGSBASEFN [function alias]

== void SGSBASEFN( const char* fnliteral )
=== sets the function name string if it hasn't already been set for the function

- alias for `if( !sgs_HasFuncName( <implicit> C ) ) sgs_FuncName( <implicit> C, x )`


sgs_SetHookFunc [function]

== void sgs_SetHookFunc( sgs_Context* C, sgs_HookFunc func, void* ctx )
=== sets the hook function and user data pointer

- hook function is called on function entry, exit and instruction change events
- setting a new hook function disables the one that was set before (if any)


sgs_GetHookFunc [function]

== SGSBOOL sgs_GetHookFunc( sgs_Context* C, sgs_HookFunc* outfunc, void** outctx )
=== writes the hook function and user data pointer that was set (if any), returns whether anything was written


sgs_Memory [function]

== void sgs_Memory( sgs_Context* C, void* ptr, size_t size )
=== allocates and frees memory, as specified in arguments

- there are four possible cases that are handled by the function:
-- `ptr` != NULL, `size` != 0: `ptr` is reallocated with new size, keeping as much data as possible, new block of memory is returned
-- `ptr` != NULL, `size` == 0: `ptr` is freed, NULL is returned
-- `ptr` == NULL, `size` != 0: a new block of memory is allocated and returned
-- `ptr` == NULL, `size` == 0: nothing is done, NULL is returned


memory allocation macros [macros]

== Memory allocation macros
=== these macros allow slightly simplified handling of memory

- `sgs_Malloc( C, size )`: allocates the memory (alias to `sgs_Memory( C, NULL, size )`)
- `sgs_Free( C, ptr )`: frees the memory (alias to `sgs_Memory( C, ptr, 0 )`)
- sgs_Realloc: alias to sgs_Memory
- the following macros expect that the variable sgs_Context* C is in the scope
-- `sgs_Alloc( what )`: allocates enough memory to fit the specified type `what`
-- `sgs_Alloc_n( what, n )`: allocates enough memory to fit `n` instances of the specified type `what`
-- `sgs_Alloc_a( what, app )`: allocates enough memory to fit the specified type `what` and `app` more bytes
-- `sgs_Dealloc( ptr )`: frees the memory
- all of these functions, including sgs_Memory, work on the same heap, thus they are interchangeable


=
== API/INFO-CTRL
=


sgs_CodeString [function]

== const char* sgs_CodeString( int type, int val )
=== returns a string for the enumeration `type` value `val`

- there are 4 enumerations to have value names returned for:
-- SGS_CODE_ER: error codes (SGS_ERROR, SGS_WARNING, ...)
-- SGS_CODE_VT: variable types (SGS_VT_BOOL, SGS_VT_FUNC, ...)
-- SGS_CODE_OP: VM instructions (SGS_SI_PUSH, SGS_SI_FORPREP, ... [internal])
-- SGS_CODE_OI: object interface function types (SGS_OP_GETINDEX, SGS_OP_GCMARK, ...)


sgs_Abort [function]

== SGSRESULT sgs_Abort( sgs_Context* C )
=== stops execution of current SGS functions up to the last C function in the stack, excluding the current

=== error codes
- SGS_ENOTFND: last or next to last function in the stack was not a SGS function


sgs_Stat [function]

== SGSMIXED sgs_Stat( sgs_Context* C, int type )
=== returns or prints information about state of SGScript VM

- the following `type` values are supported:
-- SGS_STAT_VERSION: returns the version number of the VM
-- SGS_STAT_APIVERSION: returns the API version numver of the VM
-- SGS_STAT_OBJCOUNT: returns the number of objects created in the VM
-- SGS_STAT_MEMSIZE: returns the number of bytes allocated through this SGScript context
-- SGS_STAT_NUMALLOCS: returns the number of memory allocations (incremented on each alloc/realloc)
-- SGS_STAT_NUMFREES: returns the number of memory frees (incremented on each free/realloc)
-- SGS_STAT_NUMBLOCKS: number of memory blocks currently allocated (incremented on alloc, decremented on free)
-- SGS_STAT_DUMP_STACK: prints all of the variables in the stack
-- SGS_STAT_DUMP_GLOBALS: prints all variables in the global dictionary
-- SGS_STAT_DUMP_OBJECTS: prints all objects in the context
-- SGS_STAT_DUMP_FRAMES: prints all functions in the call stack
-- SGS_STAT_DUMP_STATS: dump some info about memory and objects

- tips:
-- compare return value of SGS_STAT_VERSION against SGS_VERSION_INT if the code is version-sensitive
-- compare return value of SGS_STATE_APIVERSION against SGS_API_VERSION if dynamic loading is used and multiple versions should be supported


sgs_Cntl [function]

== int32_t sgs_Cntl( sgs_Context* C, int what, int32_t val )
=== modifies the state of the VM or returns info about it

- the following `what` values are supported:
-- SGS_CNTL_STATE: sets the new compilation state from `val`, returns the previous value
-- SGS_CNTL_GET_STATE: returns the currently set compilation state
-- SGS_CNTL_MINLEV: sets the new minimum error level from `val`, returns the previous value
-- SGS_CNTL_GET_MINLEV: returns the currently set minimum error level
-- SGS_CNTL_ERRNO: if `val` is true, sets internal errno to 0, otherwise - to `errno`, returns the previous value
-- SGS_CNTL_SET_ERRNO: sets internal errno to `val`, returns the previous value
-- SGS_CNTL_GET_ERRNO: returns the currently set internal errno
- everything else does nothing and returns 0


sgs_GetFramePtr [function]

== sgs_StackFrame* sgs_GetFramePtr( sgs_Context* C, int end )
=== returns a call stack frame pointer

- if `end` is not 0, pointer to topmost frame is returned, otherwise a pointer to first frame is returned


sgs_Errno [function (inline)]

== int sgs_Errno( sgs_Context* C, int clear )
=== copies errno to internal errno value if `clear` is not 0, otherwise internal errno value is set to 0, returns `clear`

- used with a boolean expression and chaining to set errno if the expression returned false, like this:
-- `sgs_PushBool( C, sgs_Errno( C, rename( a, b ) == 0 ) )`


sgs_SetErrno [function alias]

== int sgs_SetErrno( sgs_Context* C, int err )
=== sets a specific value `err` to the internal errno variable

- alias to `sgs_Cntl( C, SGS_CNTL_SET_ERRNO, err )`


sgs_GetLastErrno [function alias]

== int sgs_GetLastErrno( sgs_Context* C )
=== returns the currently set internal errno variable

- alias to `sgs_Cntl( C, SGS_CNTL_GET_ERRNO, 0 )`


=
== STDLIB/CORE
=


array() [function]

== array( ... )
=== returns an array, containing the arguments

- similar to the array literal, though somewhat limited

    array( "5", 6, 7.0 ) // same as ["5",6,7.0]


dict() [function]

== dict( [key, value, ...] )
=== returns a 'dict' (dictionary/hash table) object, containing the even arguments mapped to respective previous arguments

- if no arguments are passed, an empty dictionary is returned
- if an even number of arguments is passed, function returns null and emits a warning
- all even arguments must be strings or convertible to strings

    dict( "name", "John", "phone", 1234567890 ); // same as { name = "John", phone = 1234567890 }


class() [function]

== class( first, second )
=== returns a class object with `first` set as the primary data source and `second` set as the secondary/backup data source

- both arguments accept all kinds of variables but it's generally preferred to use only dicts / special objects
- refer to @CLASSES for more information on how class objects work and how to use them

    someCommonInterface = { printdata = function(){ print( this.data ); } };
    c = class( { data = "5" }, someCommonInterface );
    c.data = "6";
    c.printdata(); // prints 6


closure() [function]

== closure( callable, data )
=== returns a closure object with `callable` set as the callable variable and `data` set as the first argument for the closure call

- second argument accepts all kinds of variables, first requires a variable that can be called (SGScript function / C function / object with OP_CALL interface function defined)
- refer to @CLOSURES for more information on how closure objects work and how to use them

    counter = closure( function( data ){ return data[0]++; }, [0] );
    print( counter() ); print( counter() ); // prints "01"


isset() [function]

== isset( var, string key )
=== returns whether a property named `key` is accessible (exists) in variable `var`

    x = { a = 5 };
    isset( x, "a" ); // returns 'true'
    isset( x, "b" ); // returns 'false'
    isset( print, "thiscall" ); // returns 'true' -- works with built-in special properties too


unset() [function]

== unset( dict var, string key )
=== removes an entry named `key` from the dictionary `var`


clone() [function]

== clone( var )
=== creates a one-reference copy of the variable `var` or returns null and emits a warning on failure

- variables that are passed by value (null, bool, int, real, cfunc) or functions are returned as-is, since for value types all copies are same and functions are immutable -- TODO: what about strings? they're currently cloned

    x = { a = 5 };
    y = clone( x );
    z = x;
    x.a = 6;
    print( y.a ); // prints "5"
    print( z.a ); // prints "6"


get_keys() [function]

== get_keys( iterable var )
=== returns an array of keys found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_keys( [5,7,0] ); // returns [0,1,2]
    get_keys( {b=5,a=2} ); // returns ["b","a"]


get_values() [function]

== get_values( iterable var )
=== returns an array of values found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_values( [5,7,0] ); // returns [5,7,0]
    get_values( {b=5,a=2} ); // returns [5,2]


get_concat() [function]

== get_concat( iterable var, iterable var1, ... )
=== returns an array of values found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_concat( [1,2], {a="5",b=8} ); // returns [1,2,"5",8]


get_merged() [function]

== get_merged( iterable var, iterable var1, ... )
=== returns a dict of all key-value pairs found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_merged( [1,2], [3], {a="4"} ); // return {0=3,1=2,a="4"}


tobool() [function]

== tobool( var )
=== returns a boolean, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetBool / @sgs_ToBool in the C API

    tobool( 5 ); // returns 'true'
    tobool( "" ); // returns 'false'


toint() [function]

== toint( var )
=== returns an integer, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetInt / @sgs_ToInt in the C API

    toint( 5.4 ); // returns 5
    toint( "0xff" ); // returns 255


toreal() [function]

== toreal( var )
=== returns a real value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetReal / @sgs_ToReal in the C API

    toreal( 5 ); // returns 5.0
    toreal( "3e+2" ); // returns 3.0 -- exponential string values don't work (TODO: why)
    toreal( "0xff" ); // returns 255.0


tostring() [function]

== tostring( var )
=== returns a string value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_ToString in the C API

    tostring( 5 ); // returns "5"
    tostring( { "a" = "b" } ); // returns "{a=b}"


typeof() [function]

== typeof( var )
=== returns the type name of variable `var`, as string

- this function is equivalent to @sgs_Typeof in the C API

    typeof( 5 ); // returns "real"
    typeof( [] ); // returns "array"


typeid() [function]

== typeid( var )
=== returns the first 4 bits of the variable `var` type flags, as `int`

- returns one of the values mapped to VT_NULL/VT_BOOL/VT_INT/VT_REAL/VT_STRING/VT_FUNC/VT_CFUNC/VT_OBJECT
- this function is equivalent to @sgs_ItemType in the C API

    typeid( 5 ) == VT_REAL; // returns 'true'
    typeid( [] ); // returns 0x80 / VT_OBJECT


typeflags() [function]

== typeflags( var )
=== returns the type flags of the variable `var`, as `int`

- returns a bitfield, consisting of many different VT_* and VTF_* value combos, matching one of VTC_* values
- this function is equivalent to @sgs_ItemTypeExt in the C API

    typeflags( 5 ) == VTC_REAL; // returns 'true'
    typeid( [] ) & VT_OBJECT != 0; // returns 'true'
    typeid( "" ) & VTF_NUMERIC != 0; // returns 'false'


is_numeric() [function]

== is_numeric( var )
=== returns whether the variable `var` is numeric - one of bool/int/real or a numeric string

- all types that can always be converted to numbers are considered numeric, with two exceptions:
-- convertible objects are not numeric since validation requires an interface call and unnecessary interface calls cannot be made
-- null value is considered to be the lack of a better value, thus it cannot be considered valid, even though it always maps implicitly to the integer 0

    is_numeric( 12.124 ); // returns true
    is_numeric( "what" ); // returns false


is_callable() [function]

== is_callable( var )
=== returns whether the variable `var` is callable - a function (func/cfunc) or an object with OP_CALL defined

- this function is equivalent to @sgs_IsCallable in the C API

    is_callable( print ); // returns 'true'
    is_callable( closure( print, 5 ) ); // returns 'true'
    is_callable( 5 ); // returns 'false'


loadtypeflags() [function]

== loadtypeflags()
=== sets the globals beginning with VTF_ and VTC_

- since these features are expected to be rarely used, they're set to be loaded on-demand, not on startup

    isset( _G, "VTF_NUM" ); // returns 'false'
    loadtypeflags();
    isset( _G, "VTF_NUM" ); // returns 'true'


print(), println(), printlns() [functions]

== print( ... ), println( ... ), printlns( ... ),
=== passes all arguments, converted to strings, to the @output callback
- print passes arguments without modifications
- println passes a newline character after all variables
- printlns passes a newline character after each variable

    print( 5, "x" ); // prints "5x"
    println( 5, "x" ); // prints "5x\n"
    printlns( 5, "x" ); // prints "5\nx\n"


printvar() [function]

== printvar( var, int maxdepth = 5 )
=== passes a dump of the variable (informative string version) to the @output callback, allowing to optionally specify the maximum depth of the dump (how deep it is allowed to look for sub-variables)

    printvar( 5 ); // prints "real (5)"
    printvar( "wat" ); // prints "string [3] "wat""
    printvar( [{a=[{}]}], 2 ); /* prints:
    object (003C5F90) [0] array (1)
    [
      object (003C60A8) [1] dict (1)
      {
        ...
      }
    ]
    */


printvars() [function]

== printvars( var, ... )
=== same as a list of printvar(var); calls for each argument

- refer to @printvar() for more info


read_stdin() [function]

== read_stdin( bool all = false )
=== reads from the standard input

- if `all` is set to 'true', all standard input is read up to EOF (useful for piped input)
- if `all` is set to 'false' or not set at all, input is read up to (and excluding) the next newline character

    print "Name: "; name = read_stdin(); // waits for user input
    process( read_stdin(true) ); // loads all piped input


ftime() [function]

== ftime()
=== returns a value that is increased by a total of 1 each second (time), as real

- guaranteed to offer sub-second precision unless stated otherwise for any specific platform
- currently the precision is one millisecond

    start = ftime();
    do_something_big();
    println( "That took " $ ftime() - start $ " seconds." );


pcall() [function]

== pcall( callable func[, callable errh ])
=== calls the callable `func`, hiding internal errors from the caller or optionally passing them to callable `errh`

- `errh` error handler is called with two arguments - `int error_type, string message` - and expected to return 0-1 arguments ([int])
- error handler must return 0/null/nothing if the error has been successfully processed or the new error type otherwise
-- errors thrown inside the handler will not be caught so any error can be transformed to any other
-- an empty function behaves the same way as `pcall` without function

    include "string";
    
    function handler( type, msg )
    {
        if( string_find( msg, "not found" ) !== null )
            sys_print( type, "nooooooooooo" );
    }
    
    function handler2( type, msg )
    {
        if( string_find( msg, "not found" ) !== null )
            return SGS_ERROR;
    }
    
    pcall(function(){ print x; }); // nothing
    pcall(function(){ print x; }, handler ); // renamed warning
    pcall(function(){ print x; }, handler2 ); // changed type to error


eval() [function]

== eval( string code )
=== returns the result of evaluating the passed `code` string as SGScript code

- this function is equivalent to @sgs_EvalBuffer/@sgs_EvalString in the C API

    eval("print 5;"); // prints 5


eval_file() [function]

== eval_file( string filename )
=== returns the result of evaluating the file pointed to by `filename` as SGScript code

- this function is equivalent to @sgs_EvalFile in the C API

    eval_file("myfile.sgs"); // ???


include_library() [function]

== include_library( string lib[, bool override ] )
=== loads the global variables of the specific library `lib` in the state, returns success, as `bool`, emits a warning on failure

- lib must be one of 'fmt', 'io', 'math', 'os', 'string'
- if `override` is specified, library will be reloaded even if it was already loaded before
- this function is equivalent to the sgs_LoadLib_* functions in the C API

    printvar( sin ); // warning, null
    include_library( "math" );
    printvar( sin ); // C function


include_file() [function]

== include_file( string file[, bool override ] )
=== executes the file pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available in one of the include paths (TODO: we don't have 'em yet)
- if `override` is specified, file will be reloaded even if it was already loaded before
- this function is equivalent to @sgs_ExecFile in the C API

    include_file( "something.sgs" ); // loads something
    include_file( "something.sgs" ); // does not load it again
    include_file( "something.sgs", true ); // loads it again


include_shared() [function]

== include_shared( string file[, bool override ] )
=== runs the shared library pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before

    include_shared( "sgsjson.dll" ); // load the JSON library DLL on Windows


include() [function]

== include( string file[, bool override ] )
=== tries to load a library or a file according to the include path

- the order of actions:
-- first, a library load is attempted
-- on failure, a file is looked for by every entry of the sys_include_path variable (? - the file replacement symbol, ; - separator)
-- if file is not found, everything stops
-- if file is found, first - a library load is attempted, on failure - bytecode & source code loading
- this function is also available as a replicating statement 'include' (ex. 'include "fmt", "io";' works the same way as include("fmt"); include("io");)


import_cfunc() [function]

== import_cfunc( string file, string funcname )
=== retrieves the `funcname` function of the shared library `file`, returns success, as `bool`, emits a warning on failure

! Do not call 'sgscript_main' using this function! That function has different return value semantics so at best, something will work, a warning could be emitted and the worst case is that something will crash.

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)

    import_cfunc( "mydll.dll", "someSGScriptFunc" )();


sys_curfile() [function]

== sys_curfile()
=== returns the path of the file (as passed on load) that contains the currently executed code or `null` if the file cannot be determined (eval, C functions)

    // a.sgs
    print( sys_curfile() ); // prints "a.sgs"
    // b.sgs
    include "a.sgs";


sys_print() [function]

== sys_print( int code, string message )
=== passes a message to the internal messaging system (one that's commonly used to report errors and warnings)

! Different codes can be handled differently by the system. By default, SGS_ERROR code will stop execution and return to C code as soon as possible.

- `code` is the code to use to pass the message (ex. SGS_INFO, SGS_WARNING, SGS_ERROR)


sys_abort() [function]

== sys_abort()
=== stops execution and returns to C code as soon as possible

- this function is equivalent to @sgs_Abort in the C API

    sys_abort();
    print( 5 ); // this line is not reached


app_abort() [function]

== app_abort()
=== calls the abort() function of the C standard library (crashes the application)


app_exit() [function]

== app_exit( code = 0 )
=== calls the exit() function of the C standard library (exits the application)


sys_replevel() [function]

== sys_replevel([ level ])
=== returns the current reported error level and optionally sets a new one

! The effects of this function are not reverted automatically at any moment (unless implemented manually with hooks).

    old_level = sys_replevel( SGS_ERROR ); // report only errors or worse
    magic = calculate_magic(); // any warnings are never processed at this point
    sys_replevel( old_level ); // restore the old reported level


sys_stat() [function]

== sys_stat( code )
=== prints info about virtual machine state, everything is implementation-defined

- accepted codes are the same as for @sgs_Stat, which this function is equivalent to

    sys_stat( 11 ); // dumps all globals


errno() [function]

== errno( as_string = false )
=== returns the last relevant error number for the C standard library, as an integer or a string if `as_string` is set

- last relevant error number is defined by @sgs_Errno/@sgs_SetErrno C API functions

    data = io_file_read( "doesnotexist" ); // file that does not exist
    print errno(); // prints 2
    print errno(true); // prints "No such file or directory" on Windows


errno_string() [function]

== errno_string( int code )
=== returns the error string for the given code

- errno_string(errno()) is equivalent to errno(true)

    print errno_string(2); // prints "No such file or directory" on Windows


errno_value() [function]

== errno_value( string key )
=== returns the number for the error key (for "ENOENT" it would return 2)

- this function might be a bit slow considering that it currently does not use any extended lookup systems, such as hash tables

    data = io_file_read( "doesnotexist" );
    if( errno() == error_string("ENOENT") )
        println( "file does not exist" );


dumpvar() [function]

== dumpvar( var, int depth = 5 )
=== similar to @printvar() but returns the dump instead of printing it

- this function is equivalent to @sgs_DumpVar in the C API

    sys_error( SGS_INFO, "Extended variable info:\n" $ dumpvar(data) );


dumpvars() [function]

== dumpvars( ... )
=== similar to @printvars() but returns the dumps, concatenated, instead of printing them


gc_collect() [function]

== gc_collect()
=== runs the garbage collector on the virtual machine, waiting until it has finished

- returns the reduction in objects or false on failure

    a = [];
    a.push(a); // creates a circular dependency
    a = null; // a is not actually freed
    gc_collect(); // a is freed now


serialize() [function]

== serialize( var )
=== converts the variable to a byte buffer (string), containing the serialized data that can be recreated with @unserialize() or returns null and emits a warning on failure

- C functions and objects without OP_SERIALIZE implemented cannot be serialized

    data = serialize({ name = "A", info = "B" });
    print data; // prints random-ish garbage
    print unserialize(data); // prints {name=A,info=B}


unserialize() [function]

== unserialize( string data )
=== recreates a variable from the buffer with serialized data or returns null and emits a warning on failure

- this function will internally call global object creation functions specified in the data, so they must be defined and the state could change in the process
- for more info on serialization in SGScript, refer to @Serialization (TODO: what could this possibly lead to?)

    @serialize example


SGS_[INFO|WARNING|ERROR] [constants]

== SGS_INFO, SGS_WARNING, SGS_ERROR are defined to the values of the C macros, respectively 100, 200 and 300


VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT] [constants]

= these constants are defined to the values of the C macros (with the prefix "SVT_" in C) and can be compared with the values returned in @typeid() or @typeflags()


_G [superglobal]

== A hard-coded global value that points to the global dictionary. Can be used to access non-identifier globals.

    _G["$diff"] = 5; // no way to access this via usual globals


array [object]

- read-only properties
-- [int] size
-- [int] capacity
-- [cfunc] push
-- [cfunc] pop
-- [cfunc] shift
-- [cfunc] unshift
-- [cfunc] insert
-- [cfunc] erase
-- [cfunc] clear
-- [cfunc] reverse
-- [cfunc] resize
-- [cfunc] reserve
-- [cfunc] sort
-- [cfunc] sort_custom
-- [cfunc] sort_mapped
-- [cfunc] find
-- [cfunc] remove
- other features:
-- read/write integer index
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "array")


array.push [method]

== array.push( ... )
=== appends the variables passed to the end of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.push( 6, 7 ).push( 8 ); // a = [5,6,7,8]


array.pop [method]

== array.pop()
=== removes one item from the end of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5 ];
    a.pop(); // array is empty now
    a.pop(); // warning: "array is empty, cannot pop"


array.shift [method]

== array.shift()
=== removes one item from the beginning of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5, 6 ];
    a.shift(); // a = [6], returned 5


array.unshift [method]

== array.unshift( ... )
=== prepends the variables passed to the beginning of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.unshift( 6, 7 ); // a = [6,7,5] now


array.insert [method]

== array.insert( int pos, ... )
=== inserts the variables passed (all arguments after first) to the position specified in the array or emits a warning on failure (index out of bounds), returns the array for chaining

- `pos` accepts both positive and negative values, the meaning is "which value to insert before"
-- negative values are converted to positive ones by adding (<size> + 1) to them
-- beginning of array can be inserted to using position 0 or (- <size> - 1)
-- end of array can be inserted to using position <size> or -1

    a = [ 5, 7 ];
    a.insert( 1, 6 ); // inserts 6 at position 1 (before item with index 1)
    a.insert( -1, 8 ); // appends to the end of array, a = [5,6,7,8] now


array.erase [method]

== array.erase( int[, int] )
=== erases item or a range of items from the array, depending on the arguments passed or emits a warning on failure, returns the array for chaining

- both arguments have same index processing rules as @array.insert(), but with one difference - if both arguments are passed, after resolving (converting negative indices to positive ones, if there are any), first must be smaller than second

    a = [ 5, 6, 7, 8 ];
    a.erase( 1, 2 ); // erases all items between position 1 and 2, including; gives a = [5,8]
    a.erase( 0 ); // a = [8]


array.clear [method]

== array.clear()
=== erases all items from the array, returns the array for chaining

    a = [ 1, "asd", 8 ];
    a.clear(); // a = []


array.reverse [method]

== array.reverse()
=== reverses the order of items in the original array, returns the original array for chaining

    a = [ 1, 2, 3 ];
    b = a;
    a.reverse(); // a = [3,2,1]
    print( b ); // prints [3,2,1]


array.resize [method]

== array.resize( int size )
=== changes the size of the array, returns the array for chaining

- `size` must be larger than or equal to 0
- if previous size was less than passed to the method, null variables are appended
- if previous size was more than passed to the method, items are popped from the end of the array
- if size was not changed, nothing else will change

    a = [ 5, 6, 7 ];
    a.resize( 5 ); // a = [5,6,7,null,null]
    a.resize( 2 ); // a = [5,6]


array.reserve [method]

== array.reserve( int capacity )
=== reserves the space for the requested number of elements in the array, returns the array for chaining

- `capacity` must be larger than or equal to 0
- if previous capacity was less than passed to the method, capacity will be increased to the requested amount
- if previous capacity was more than or equal to what was passed to the method, nothing will change

    a = [ 5, 6, 7 ];
    a.capacity( 1 ); // nothing happens
    a.capacity( 5 ); // a.capacity = 5 and two variable additions can now happen without reallocations


array.sort [method]

== array.sort([ bool reverse ])
=== sorts the array using the @sgs_Compare C API function for comparisons, returns the array for chaining

- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    a.sort(); // a = [5,6,7,8]


array.sort_custom [method]

== array.sort_custom( callable[, bool reverse ] )
=== sorts the array using the callable for comparisons, returns the array for chaining

! This function is considerably slower than @array.sort or @array.sort_mapped so prefer those if performance matters.

- callable must return an integer, specifying the relative order of the two passed arguments: less than 0 if first variable should be placed before second, greater than 0 if first variable should be placed after second, or 0 if it doesn't matter (TODO: unsafe with big integers/FP return values! something must be done)
- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    // this code will sort numbers into odd/even ones and in ascending order
    a.sort_custom( function(a,b){return a-b+(b%2-a%2)*1000; } ); // a = [5,7,6,8]


array.sort_mapped [method]

== array.sort_mapped( array map[, bool reverse ] );
=== sorts the array by sorting the passed array and applying the index map to the first one, returns the array for chaining

- both arrays must have the same size, otherwise a warning is emitted
- all variables in the mapping array are interpreted as 'real' values
- if `reverse` is true, array is sorted in the reverse order

    a = [ 5, 6, 7, 8 ];
    b = [ 3, 1, 4, 2 ];
    a.sort_mapped( b ); // a = [6,8,5,7]


array.find [method]

== array.find( var item[, bool strict[, int from ]] )
=== attempts to find `item` in array, starting from 0 or the index passed with `from`, if it exists, using basic or strict equality comparisons (depending on `strict`), returning the index or 'null' if item was not found

- if strict comparisons are enabled, variable types are also checked for equality

    a = [ 5, 6, 7, 8 ];
    a.find( "7" ); // returns 2
    a.find( "7", true ); // returns null


array.remove [method]

== array.remove( var item[, bool strict[, bool all[, int from ]]] )
=== attepts to find and remove first or all `item` variables in array (depending on `all`), according to the rules specified in @array.find(), returning the number of removed items

    a = [ 5, 2, 6, 7, 8, 2 ];
    a.remove( "7" ); // returns 1; a = [5,2,6,8,2]
    a.remove( "6", true ); // returns 0; a remains unchanged
    a.remove( 2, false, true ); // returns 2; a = [5,6,8]


dict [object]

- features:
-- read/write string index
-- read/write string properties and integer index-via-property
-- full content dump
-- tostring = quick content dump
-- tobool = size != 0
-- iterator
-- cloning
-- serialization
-- GC-safe
-- type identification (returns the string "dict")


class [object]

- read/write properties
-- [var] _super
- other features
-- read/write pass-through index
-- read/write pass-through properties (except string "_super")
-- full content dump
-- tobool = ENOTSUP, overridable via "__tobool"
-- toint = ENOTSUP, overridable via "__toint"
-- toreal = ENOTSUP, overridable via "__toreal"
-- tostring = "class", overridable via "__tostring"
-- cloning, overridable via "__clone"
-- type identification (returns the string "class", overridable via "__typeof")
-- overridable arithmetic/comparison operations
-- overridable object call
-- serialization
-- GC-safe


closure [object]

- features
-- full content dump
-- tostring = "closure"
-- type identification (returns the string "closure")
-- object call to callable, using the attached first argument
-- GC-safe


=
== STDLIB/FMT
=


fmt_pack [function]

== fmt_pack( string fmt, ... )
=== packs the given arguments using the format `fmt` and returns the byte buffer or returns null and emits a warning on failure

- the format: character command list
-- 0-9: add a digit to multiplier
-- =/</>/@: "=" sets host byte order, "<" - little endian byte order, ">" - big endian, "@" - inverted
-- +/-: "+" - unsigned integers, "-" - signed integers
-- c/w/l/q/p: integers (c - char, 1 byte, w - word, 2 bytes, l - long, 4 bytes, q - quad-word, 8 bytes, p - pointer/size, platform-specific size of 4/8 bytes, usually)
-- f/d: floating-point numbers: "f" - single precision, "d" - double precision
-- s: string, multiplier sets length instead of count, as with other items
-- x: padding byte (does not get read or written, can be used to advance the pointer)
-- space/tab/CR/LF: invisible to the parser
-- everything else resets multiplier, does nothing
- sign modifiers do nothing in fmt_pack, refer to @fmt_unpack() for their usage info

    printvar( fmt_pack( "3cf", 0, 1, 2, 3 ) ); // prints 'string [7] "\x00\x01\x02\x00\x00@@"'


fmt_unpack [function]

== fmt_unpack( string fmt, string data )
=== unpacks the byte buffer `data` using the format `fmt`, returns array of unpacked items

- unpacks c/w/l/q/p to integers, f/d to floats, s to strings
- if signed numbers are expected (as set by the "-" modifier), the sign bit of the expected type is extended to the end of the native integer type, this makes the loaded integer signed
- refer to @fmt_pack() for more info about the format

    print fmt_unpack( "3ld", fmt_pack( "3ld", 0, 1, 2, 3 ) ); // prints [0,1,2,3]


fmt_pack_count [function]

== fmt_pack_count( string fmt )
=== calculates the number of items to be expected in an unpacked array / required to make a successful fmt_pack call

- refer to @fmt_pack() for more info about the format

    print fmt_pack_count( "3ld" ); // prints 4


fmt_pack_size [function]

== fmt_pack_size( string fmt )
=== calculates the number of bytes generated by a successful fmt_pack call / required to successfully unpack data using the given format

- refer to @fmt_pack() for more info about the format

    print fmt_pack_size( "3ld" ); // prints 20


fmt_base64_encode [function]

== fmt_base64_encode( string data )
=== encodes data to produce base64 text data

- encoding is done using the following table (shortened): "A-Za-z0-9+/"

    print fmt_base64_encode( "hello world" ); // prints "aGVsbG8gd29ybGQ="


fmt_base64_decode [function]

== fmt_base64_decode( string b64text )
=== decodes base64 text data

- decoding is done using the table mentioned in @fmt_base64_encode()

    fmt_base64_decode( fmt_base64_encode( "hello world" ) ) == "hello world" // returns true


fmt_text [function]

== fmt_text( string text, ... )
=== parses all format specifiers in `text` and returns the result

- the general format of a format specifier is as follows: {fmt[size][.prec][r][p<char>]}
-- fmt: one-character output type (b-binary, o-octal, d-decimal, x/X-hexadecimal, f-floating-point, g/G-compact floating-point, e/E-scientific floating-point, s-valid string, c-always converted to string)
-- size: minimum number of characters to print
-- prec: precision of floating-point variables, string length limit
-- r: add "r" to right-pad (left-justify)
-- p<char>: add "p" and any character to set that character as the padding character (default: space/0x20)
- if anything unexpected happens, this function will emit a warning and put "#error#" in the place of a format specifier

    print fmt_text( "{d} -> {x}", 1337, 1337 ); // prints "1337 -> 539"
    print fmt_text( "null: {d}, {s}, {c}", null, null, null ); // prints "null: #error#, #error#, null" and emits two warnings for item 1 and item 2
    print fmt_text( "pi: {f10.10r} {g10r} {E10r}", M_PI, M_PI, M_PI ); // "pi: 3.1415926536 3.14159    3.141593E+000"
    TODO: more useful examples!


fmt_parser [function]

== fmt_parser( callable[, buffersize ] )
=== creates a @fmt_parser object, connected to the callable

- the callable is a function that returns at most the number of bytes requested from the stream
-- if previous request reached end, subsequent requests must return 'null'

    f = io_file( "test.txt", FILE_READ ); // TODO: this is too complex for basic features, add fmt_file_parser
    p = fmt_parser( closure( function(file,num){ if( file.eof() ) return null; return file.read( num ); }, f ) );


fmt_string_parser [function]

== fmt_string_parser( string, offset = 0 ) TODO: what about buffer size?
=== creates a @fmt_parser object, connected to a string reader, initialized to the given offset

    p = fmt_string_parser( "this is a test" );
    p.readcc( "a-z" ); // returns "this"


fmt_charcc [function]

== fmt_charcc( string char, string class )
=== checks if the first character of string `char` is included in the character class `class`

- character class is a regex-like list of specific symbols and ranges (its low and high symbols separated by "-"), optionally prepended by "^" that inverts the scope of the class

    fmt_charcc( ".", "a-zA-Z0-9" ); // returns false
    fmt_charcc( "x", "a-zA-Z0-9" ); // returns true


fmt_parser [object]

* read-only properties
 - [bool] at_end
 - [bool] stream_offset
 - [cfunc] read
 - [cfunc] getchar
 - [cfunc] readcc
 - [cfunc] skipcc
* other features:
 - GC-safe
(TODO: do we need a more feature-complete object?)


fmt_parser.read [method]

== fmt_parser.read( int num )
=== reads at most `num` bytes from stream and returns them as string

- if 0 bytes are returned, it's quite safe to assume that the function has reached the end of file but check the at_end property to be sure
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( 5 ); // returns "actio"


fmt_parser.getchar [method]

== fmt_parser.getchar( bool peek = false, bool as_int = false )
=== returns a character from stream

- if `peek` is true, stream is not advanced (next read operation will also work on the same character)
- if `as_int` is true, character is returned as integer (as one-character string otherwise)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "action" );
    stream.read( true ); // returns "a"
    stream.read( true, true ); // returns 97
    stream.read(); // returns "a"
    stream.read(); // returns "c"


fmt_parser.readcc [method]

== fmt_parser.readcc( string class, int num = 2^31-1 (0x7fffffff) )
=== reads and returns at most `num` bytes that match the character class `class`

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^" (TODO: is this necessary?)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.readcc( "a-z" ); // returns "what"
    stream.readcc( "^a-z" ); // returns " "


fmt_parser.skipcc [method]

== fmt_parser.skipcc( string class, int num = 2^31-1 (0x7fffffff) )
=== skips at most `num` bytes that match the character class `class` and returns the number of bytes skipped

- returns null and emits a warning if the class is empty/only contains the inversion symbol "^" (TODO: is this necessary?)
- may return null and emit a warning on unexpected read errors

    stream = fmt_string_parser( "what is this" );
    stream.skipcc( "a-z" ); // returns 4
    stream.skipcc( "^a-z" ); // returns 1


=
== STDLIB/IO
=


io_setcwd [function]

== io_setcwd( string cwd )
=== sets the current working directory, returns bool/sets errno

- wraps the C library function chdir


io_getcwd [function]

== io_getcwd()
=== returns the current working directory or null, if for some reason an error occured (TODO: getcwd(NULL,0) is UB, how wide is support for expected behavior?)

- wraps the C library function getcwd/_getcwd


io_rename [function]

== io_rename( string path, string newname )
=== attempts to rename the file, returns bool/sets errno

- wraps the C library function rename, with one important difference - moving the file is not allowed, regardless of platform support (TODO: is the restriction safe and necessary?)


io_file_exists [function]

== io_file_exists( string file )
=== checks if file exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions fopen/fclose


io_dir_exists [function]

== io_dir_exists( string dir )
=== checks if directory exists and is accessible by the process at the moment, returns true on success, false otherwise

- uses the C library functions opendir,closedir where supported, _findfirst,_findclose otherwise (Windows/MSVC)


io_stat [function]

== io_stat( string fsitem )
=== returns info about the file system item `fsitem`, as dict

- the returned object contains the following properties:
-- atime: last access time
-- ctime: creation time
-- mtime: last modification time
-- type: enum (one of FST_DIR/FST_FILE/FST_UNKNOWN) TODO: do we need more?
-- size: size of item
- uses the C library function stat/_stat


io_dir_create [function]

== io_dir_create( string path, int mode = 0o777 )
=== attempts to create a directory at the specified path, with the specified access mode `mode`, returns bool/sets errno

- `mode` is ignored on Windows
- uses the C library function mkdir/_mkdir


io_dir_delete [function]

== io_dir_delete( string path )
=== attempts to delete a directory at the specified path, returns bool/sets errno

- uses the C library function rmdir/_rmdir


io_file_delete [function]

== io_file_delete( string path )
=== attempts to delete a file at the specified path, returns bool/sets errno

- uses the C library function remove


io_file_write [function]

== io_file_write( string path, string data )
=== writes the byte buffer `data` to the file pointed to by `path`, returns bool/sets errno


io_file_read [function]

== io_file_read( string path )
=== reads the byte buffer from file at `path`, returns buffer as string or null/sets errno


io_file [object]

- read-only properties
-- [int] offset
-- [int] size
-- [bool] error
-- [bool] eof
-- [cfunc] open
-- [cfunc] close
-- [cfunc] read
-- [cfunc] write
-- [cfunc] seek
-- [cfunc] flush
-- [cfunc] setbuf
- other features:
-- tostring = "file"
-- tobool = returns whether file is open or not
-- GC-safe
-- type identification (returns the string "file")


io_file.open [method]

== io_file.open( string name, int mode )
=== closes the previously open file if any, opens the file `name` for operation mode `mode`, returns bool/sets errno

- `mode` must be one of FILE_READ, FILE_WRITE or FILE_READ|FILE_WRITE
- file is always opened in binary mode

    f = io_file();
    f.open( "file" ); // returns true or false, sets errno accordingly


io_file.close [method]

== io_file.close()
=== closes the previously open file, if any, returns whether the file was open or not

    f = io_file( "file.txt" );
    f.close(); // returns true if the file existed
    f.close(); // returns false


io_file.read [method]

== io_file.read( int num )
=== reads and returns at most `num` bytes from file, sets errno


io_file.write [method]

== io_file.write( string data )
=== writes the byte buffer `data` to the file, sets errno


io_file.seek [method]

== io_file.seek( int off, int mode )
=== sets the offset in file, returns bool/sets errno

- `mode` must be one of SEEK_SET (sets as-is), SEEK_CUR (sets relative to current), SEEK_END (sets relative to end)


io_file.flush [method]

== io_file.flush()
=== flushes a buffered file, returns bool


io_file.setbuf [method]

== io_file.setbuf( int size )
=== sets the size of file buffer (0 to disable buffering), returns bool

- buffering allows to avoid committing each write immediately to disk, resulting in a performance gain, however it may introduce issues if application is expected to fail at any moment, resulting in some data not being written in such cases


io_file [function]

== io_file([ string name, int mode ])
=== creates and returns a file, optionally allowing to open it on creation

- see @io_file.open() for more info on opening the file


io_dir (directory_iterator) [object]

- features:
-- tostring = "directory_iterator"
-- iterator interface (key = whether real item, value = item name)
--- real items are all except "." and ".."
-- returns self as iterator
-- GC-safe
-- type identification (returns the string "directory_iterator")


io_dir [function]

== io_dir( string dir )
=== creates a directory iterator for the directory `dir`, sets errno, returns null and emits a warning on failure


FILE_[READ|WRITE] [constants]

== mode constants for @io_file.open() / @io_file()


SEEK_[SET|CUR|END] [constants]

== mode constants for @io_file.seek()


FST_[UNKNOWN|FILE|DIR] [constants]

== file system item type constants for @io_stat()


=
== STDLIB/MATH
=


abs() [function]

== abs( x )
=== returns the absolute value of `x`, as `real`

    abs( 2.2 ); // real (2.2)
    abs( -3.1 ); // real (3.1)


floor() [function]

== floor( x )
=== returns the largest integer that is not bigger than `x`, as `real`

    floor( 3.4 ); // real (3)
    floor( 3.8 ); // real (3)
    floor( 4.2 ); // real (4)
    floor( -3.1 ); // real (-4)


ceil() [function]

== ceil( x )
=== returns the smallest integer that is not smaller than `x`, as `real`

    ceil( 3.4 ); // real (4)
    ceil( 3.8 ); // real (4)
    ceil( 4.2 ); // real (5)
    ceil( -3.1 ); // real (-3)


round() [function]

== round( x )
=== returns the closest integer to `x`, as `real`

    round( 3.4 ); // real (3)
    round( 3.8 ); // real (4)
    round( 4.2 ); // real (4)
    round( -3.1 ); // real (-3)


pow() [function]

== pow( x, y )
=== returns `x` raised to the power `y`, as `real`

- If base (`x`) is negative and exponent (`y`) is not an integral value, or if base is zero and exponent is negative, function returns `null` and emits a warning message.

    pow( 2, 5 ); // real (32)
    pow( 9, 0.5 ); // real (3)
    pow( -1, 0.5 ); // null; Warning: pow(): mathematical error


sqrt() [function]

== sqrt( x )
=== returns the square root of `x`, as `real`

- If `x` is negative, function returns `null` and emits a warning message.

    sqrt( 16 ); // real (4)
    sqrt( -1 ); // null; Warning: sqrt(): mathematical error


log() [function]

== log( x, y )
=== returns the base-`y` logarithm of `x`, as `real`

- If `x <= 0`  or  `b <= 0`  or  `b = 1`, function returns `null` and emits a warning message.

    log( 9, 3 ); // real (2)
    log( -1, 3 ); // .. or ..
    log( 3, 0 ); // .. or ..
    log( 3, 1 ); // null; Warning: log(): mathematical error


sin() [function]

== sin( x )
=== returns the sine of angle `x` in radians, as `real`

    sin( 0 ); // real (0)
    sin( M_PI / 2 ); // real (1)
    sin( M_PI / 4 ); // real (0.707107)


cos() [function]

== cos( x )
=== returns the cosine of angle `x` in radians, as `real`

    sin( 0 ); // real (1)
    sin( M_PI ); // real (-1)
    sin( M_PI / 4 ); // real (0.707107)


tan() [function]

== tan( x )
=== returns the tangent of angle `x` in radians, as `real`

    tan( 0 ); // real (0)
    tan( 1 ); // real (1.55741)
    tan( M_PI / 4 ); // real (1)


asin() [function]

== asin( x )
=== returns the arcsine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    asin( -1 ); // real (-1.5708)
    asin( 0 ); // real (0)
    asin( 2 ); // null; Warning: asin(): mathematical error


acos() [function]

== acos( x )
=== returns the arccosine of `x` (angle in radians), as `real`

- If `x` is outside the [-1,1] range, function returns `null` and emits a warning message

    acos( -1 ); // real (3.14159)
    acos( 0 ); // real (1.5708)
    acos( 2 ); // null; Warning: acos(): mathematical error


atan() [function]

== atan( x )
=== returns the arctangent of `x` (angle in radians), as `real`

    atan( 0 ); // real (0)
    atan( 1 ); // real (0.785398)
    atan( 9999999 ); // real (1.5708)


atan2() [function]

== atan2( y, x )
=== returns the extended arctangent of y/x (angle in radians), as `real`

- Signs of `x` and `y` are used to determine the quadrant, thus `y` is expected to be the sine of the angle to be returned (the `y` coordinate of a point) and `x` - the cosine (the `x` coordinate).

! Due to the common requirement to use this function to determine the angle between two somewhat random points (usually from a simulation), it will not emit a warning when both arguments are 0 - it will return 0 instead.

    atan2( 0, 1 ); // real (0)
    atan2( 1, 0 ); // real (1.5708)
    atan2( -1, -1 ); // real (-2.35619)
    atan2( 0, 0 ); // real (0)


deg2rad() [function]

== deg2rad( x )
=== returns angle, converted from degrees to radians, as `real`

    deg2rad( 0 ); // real (0)
    deg2rad( 180 ); // real (3.14159)
    deg2rad( -90 ); // real (-1.5708)


rad2deg() [function]

== rad2deg( x )
=== returns angle, converted from radians to degrees, as `real`

    rad2deg( 0 ); // real (0)
    rad2deg( M_PI ); // real (180)
    rad2deg( -M_PI / 2 ); // real (-90)


M_[PI|E] [constants]

== M_PI
=== the ratio of circumference of a circle to its diameter (pi)
- the value of this constant is `3.14159265358979323846`

== M_E
=== the natural logarithmic base (e)
- the value of this constant is `2.7182818284590452354`


=
== STDLIB/OS
=


os_gettype [function]

== os_gettype()
=== returns the name of the closest known match for the operating system type, defined at library compile time

- the function can detect and return the following OSes at the moment (with the preprocessor define in braces):
-- "Windows" (_WIN32)
-- "Linux" (__linux)
-- "Unix" (__unix)
-- "POSIX" (__posix)
-- "Unknown" (..any other)


os_command [function]

== os_command( string cmd )
=== passes a command to the OS command processor, returns the integer return value

! this function can be extremely unsafe in multithreaded/incontrollable environments due to the completely undefined outcome of the call

- uses the C library function 'system'


os_getenv [function]

== os_getenv( string var )
=== returns the value for the environment variable `var` or null, if there is no such value


os_putenv [function]

== os_putenv( string cmd )
=== sets the value for the environment variable specified in command `cmd`, returns success as bool

- `cmd` has the format "<name>=<value>"


os_time [function]

== os_time( real tz = <local> )
=== returns the time in seconds, as integer, optionally from a different timezone `tz`


os_get_timezone [function]

== os_get_timezone( bool as_string = false )
=== returns the timezone set in the operating system, optionally as string in the format "(+/-)HH:MM"


os_date_string [function]

== os_date_string( string fmt, int time = os_time() )
=== returns the date/time string in the format `fmt`, optionally for a different time `time`

- the following item specifiers are supported (*-local-specific): (TODO: what about setting the locale?)
-- %a: abbreviated weekday name *
-- %A: full weekday name *
-- %b: abbreviated month name *
-- %B: full month name *
-- %c: full date/time *
-- %x: full date *
-- %X: full time *
-- %Z: timezone name/abbreviation (could be an empty string) *
-- %U: week number with first Sunday as the first day of week one *
-- %W: week number with first Monday as the first day of week one *
-- %C: year/100, as integer
-- %d: zero-padded day of the month (01-31)
-- %e: space-padded day of the month ( 1-31)
-- %F: date, shortcut of "%Y-%m-%d"
-- %H: hour in 24h format (00-23)
-- %I: hour in 12h format (01-12)
-- %j: day of the year (001-366)
-- %m: month number (01-12)
-- %M: minute (00-59)
-- %p: AM or PM
-- %R: hour/minute time, shortcut to %H:%M
-- %s: second (00-61)
-- %T: time, shortcut to %H:%M:%S
-- %u: weekday with Sunday as 0
-- %w: weekday with Monday as 1
-- %y: 2-digit year (00-99)
-- %Y: year
-- %f: file-safe full time, shortcut to %Y-%m-%d_%H-%M-%S
-- %t: the UNIX timestamp
-- %%: prints "%"
-- %<any other>: prints both characters


os_parse_time [function]

== os_parse_time( int time = os_time() )
=== returns `time` split into parts, as dict

- the returned dict contains the following properties (all are integers):
-- year (1900-????)
-- month (1-12)
-- day (1-31)
-- weekday (1-7)
-- yearday (1-366)
-- hours (0-23)
-- minutes (0-59)
-- seconds (0-61)


os_make_time [function]

== os_make_time( int sec, int min = 0, int hour = 0, int mday = 0, int mon = 0, int year = 0 )
=== returns time as UNIX timestamp, generated from the arguments, using them as hints (under-/overflows may have some unexpected behavior)


=
== STDLIB/STRING
=


string_cut() [function]

== string_cut( string str, int from[, int to[, int flags]] )
=== returns a part of string `str`, `from` and `to` being positions of the first and last character returned, respectively

- if `to` is not specified, `to` is assumed to be the position of the last character in string `str`
- if `from` or `to` are negative, they point to characters before the end of string (-1 being the last one)
- available values for `flags`:
-- `NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRICT_RANGES` - emit warnings on out of bounds `from`/`to` values instead of silently ignoring the outside characters

    string_cut( "01234567", 3, 5 ); // string [3] "345"


string_part() [function]

== string_part( string str, int from[, int len[, int flags]] )
=== returns a part of string `str`, starting at `from`, at most `len` characters

- if `len` is not specified, `len` is assumed to be the number of characters between `from` and the end of string `str`
- if `from` is negative, it points to characters before the end of string (-1 being the last one)
- if `len` is negative, the maximum length of returned string is the sum of `len` and string `str` length
- available values for `flags`:
-- `NO_REV_INDEX` - emit warnings on negative indices, instead of handling them
-- `STRICT_RANGES` - emit warnings on out of bounds `from`/`len` values instead of silently ignoring the outside characters

    string_part( "01234567", 3, 3 ); // string [3] "345"


string_reverse() [function]

== string_reverse( string str )
=== returns `str` with all the bytes in reversed order

! This function will not work correctly with multibyte-encoded strings.

    string_reverse( "noitca" ); // string [6] "action"








