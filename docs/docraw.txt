
=
== STDLIB/CORE-FUNCTIONS
=

array() [function]

== array( ... )
=== returns an array, containing the arguments

- similar to the array literal, though somewhat limited

    array( "5", 6, 7.0 ) // same as ["5",6,7.0]


dict() [function]

== dict( [key, value, ...] )
=== returns a 'dict' (dictionary/hash table) object, containing the even arguments mapped to respective previous arguments

- if no arguments are passed, an empty dictionary is returned
- if an even number of arguments is passed, function returns null and emits a warning
- all even arguments must be strings or convertible to strings

    dict( "name", "John", "phone", 1234567890 ); // same as { name = "John", phone = 1234567890 }


class() [function]

== class( first, second )
=== returns a class object with `first` set as the primary data source and `second` set as the secondary/backup data source

- both arguments accept all kinds of variables but it's generally preferred to use only dicts / special objects
- refer to @CLASSES for more information on how class objects work and how to use them

    someCommonInterface = { printdata = function(){ print( this.data ); } };
    c = class( { data = "5" }, someCommonInterface );
    c.data = "6";
    c.printdata(); // prints 6


closure() [function]

== closure( callable, data )
=== returns a closure object with `callable` set as the callable variable and `data` set as the first argument for the closure call

- second argument accepts all kinds of variables, first requires a variable that can be called (SGScript function / C function / object with OP_CALL interface function defined)
- refer to @CLOSURES for more information on how closure objects work and how to use them

    counter = closure( function( data ){ return data[0]++; }, [0] );
    print( counter() ); print( counter() ); // prints "01"


isset() [function]

== isset( var, string key )
=== returns whether a property named `key` is accessible (exists) in variable `var`

    x = { a = 5 };
    isset( x, "a" ); // returns 'true'
    isset( x, "b" ); // returns 'false'
    isset( print, "thiscall" ); // returns 'true' -- works with built-in special properties too


unset() [function]

== unset( dict var, string key )
=== removes an entry named `key` from the dictionary `var`


clone() [function]

== clone( var )
=== creates a one-reference copy of the variable `var` or returns null and emits a warning on failure

- variables that are passed by value (null, bool, int, real, cfunc) or functions are returned as-is, since for value types all copies are same and functions are immutable -- TODO: what about strings? they're currently cloned

    x = { a = 5 };
    y = clone( x );
    z = x;
    x.a = 6;
    print( y.a ); // prints "5"
    print( z.a ); // prints "6"


get_keys() [function]

== get_keys( iterable var )
=== returns an array of keys found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_keys( [5,7,0] ); // returns [0,1,2]
    get_keys( {b=5,a=2} ); // returns ["b","a"]


get_values() [function]

== get_values( iterable var )
=== returns an array of values found in the iterable object `var` or returns null and emits a warning on failure

- `var` must be an iterable object (has interface OP_CONVERT defined and successfully handles a CONVOP_TOITER request) - such objects are `array`, `dict` and `io_dir`

    get_values( [5,7,0] ); // returns [5,7,0]
    get_values( {b=5,a=2} ); // returns [5,2]


get_concat() [function]

== get_concat( iterable var, iterable var1, ... )
=== returns an array of values found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_concat( [1,2], {a="5",b=8} ); // returns [1,2,"5",8]


get_merged() [function]

== get_merged( iterable var, iterable var1, ... )
=== returns a dict of all key-value pairs found in all iterable objects passed to the function or returns null and emits a warning on failure

    get_merged( [1,2], [3], {a="4"} ); // return {0=3,1=2,a="4"}


tobool() [function]

== tobool( var )
=== returns a boolean, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetBool / @sgs_ToBool in the C API

    tobool( 5 ); // returns 'true'
    tobool( "" ); // returns 'false'


toint() [function]

== toint( var )
=== returns an integer, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetInt / @sgs_ToInt in the C API

    toint( 5.4 ); // returns 5
    toint( "0xff" ); // returns 255


toreal() [function]

== toreal( var )
=== returns a real value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_GetReal / @sgs_ToReal in the C API

    toreal( 5 ); // returns 5.0
    toreal( "3e+2" ); // returns 3.0 -- exponential string values don't work (TODO: why)
    toreal( "0xff" ); // returns 255.0


tostring() [function]

== tostring( var )
=== returns a string value, generated from variable `var` using the @conversion rules

- this function is equivalent to @sgs_ToString in the C API

    tostring( 5 ); // returns "5"
    tostring( { "a" = "b" } ); // returns "{a=b}"


typeof() [function]

== typeof( var )
=== returns the type name of variable `var`, as string

- this function is equivalent to @sgs_Typeof in the C API

    typeof( 5 ); // returns "real"
    typeof( [] ); // returns "array"


typeid() [function]

== typeid( var )
=== returns the first 4 bits of the variable `var` type flags, as `int`

- returns one of the values mapped to VT_NULL/VT_BOOL/VT_INT/VT_REAL/VT_STRING/VT_FUNC/VT_CFUNC/VT_OBJECT
- this function is equivalent to @sgs_ItemType in the C API

    typeid( 5 ) == VT_REAL; // returns 'true'
    typeid( [] ); // returns 0x80 / VT_OBJECT


typeflags() [function]

== typeflags( var )
=== returns the type flags of the variable `var`, as `int`

- returns a bitfield, consisting of many different VT_* and VTF_* value combos, matching one of VTC_* values
- this function is equivalent to @sgs_ItemTypeExt in the C API

    typeflags( 5 ) == VTC_REAL; // returns 'true'
    typeid( [] ) & VT_OBJECT != 0; // returns 'true'
    typeid( "" ) & VTF_NUMERIC != 0; // returns 'false'


is_numeric() [function]

== is_numeric( var )
=== returns whether the variable `var` is numeric - one of bool/int/real or a numeric string

- all types that can always be converted to numbers are considered numeric, with two exceptions:
-- convertible objects are not numeric since validation requires an interface call and unnecessary interface calls cannot be made
-- null value is considered to be the lack of a better value, thus it cannot be considered valid, even though it always maps implicitly to the integer 0

    is_numeric( 12.124 ); // returns true
    is_numeric( "what" ); // returns false


is_callable() [function]

== is_callable( var )
=== returns whether the variable `var` is callable - a function (func/cfunc) or an object with OP_CALL defined

    is_callable( print ); // returns 'true'
    is_callable( closure( print, 5 ) ); // returns 'true'
    is_callable( 5 ); // returns 'false'


loadtypeflags() [function]

== loadtypeflags()
=== sets the globals beginning with VTF_ and VTC_

- since these features are expected to be rarely used, they're set to be loaded on-demand, not on startup

    isset( _G, "VTF_NUM" ); // returns 'false'
    loadtypeflags();
    isset( _G, "VTF_NUM" ); // returns 'true'


print(), println(), printlns() [functions]

== print( ... ), println( ... ), printlns( ... ),
=== passes all arguments, converted to strings, to the @output callback
- print passes arguments without modifications
- println passes a newline character after all variables
- printlns passes a newline character after each variable

    print( 5, "x" ); // prints "5x"
    println( 5, "x" ); // prints "5x\n"
    printlns( 5, "x" ); // prints "5\nx\n"


printvar() [function]

== printvar( var, int maxdepth = 5 )
=== passes a dump of the variable (informative string version) to the @output callback, allowing to optionally specify the maximum depth of the dump (how deep it is allowed to look for sub-variables)

    printvar( 5 ); // prints "real (5)"
    printvar( "wat" ); // prints "string [3] "wat""
    printvar( [{a=[{}]}], 2 ); /* prints:
    object (003C5F90) [0] array (1)
    [
      object (003C60A8) [1] dict (1)
      {
        ...
      }
    ]
    */


printvars() [function]

== printvars( var, ... )
=== same as a list of printvar(var); calls for each argument

- refer to @printvar() for more info


read_stdin() [function]

== read_stdin( bool all = false )
=== reads from the standard input

- if `all` is set to 'true', all standard input is read up to EOF (useful for piped input)
- if `all` is set to 'false' or not set at all, input is read up to (and excluding) the next newline character

    print "Name: "; name = read_stdin(); // waits for user input
    process( read_stdin(true) ); // loads all piped input


ftime() [function]

== ftime()
=== returns a value that is increased by a total of 1 each second (time), as real

- guaranteed to offer sub-second precision unless stated otherwise for any specific platform
- currently the precision is one millisecond

    start = ftime();
    do_something_big();
    println( "That took " $ ftime() - start $ " seconds." );


eval() [function]

== eval( string code )
=== returns the result of evaluating the passed `code` string as SGScript code

- this function is equivalent to @sgs_EvalBuffer/@sgs_EvalString in the C API

    eval("print 5;"); // prints 5


eval_file() [function]

== eval_file( string filename )
=== returns the result of evaluating the file pointed to by `filename` as SGScript code

- this function is equivalent to @sgs_EvalFile in the C API

    eval_file("myfile.sgs"); // ???


include_library() [function]

== include_library( string lib[, bool override ] )
=== loads the global variables of the specific library `lib` in the state, returns success, as `bool`, emits a warning on failure

- lib must be one of 'fmt', 'io', 'math', 'os', 'string'
- if `override` is specified, library will be reloaded even if it was already loaded before
- this function is equivalent to the sgs_LoadLib_* functions in the C API

    printvar( sin ); // warning, null
    include_library( "math" );
    printvar( sin ); // C function


include_file() [function]

== include_file( string file[, bool override ] )
=== executes the file pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available in one of the include paths (TODO: we don't have 'em yet)
- if `override` is specified, file will be reloaded even if it was already loaded before
- this function is equivalent to @sgs_ExecFile in the C API

    include_file( "something.sgs" ); // loads something
    include_file( "something.sgs" ); // does not load it again
    include_file( "something.sgs", true ); // loads it again


include_shared() [function]

== include_shared( string file[, bool override ] )
=== runs the shared library pointed to by `file`, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before

    include_shared( "sgsjson.dll" ); // load the JSON library DLL on Windows


include_module() [function]

== include_module( string file[, bool override ] )
=== runs the shared library pointed to by `file`, first applying file name transformation rules, returns success, as `bool`, emits a warning on failure

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)
- the library must contain a 'sgscript_main' function that will be called on initialization
- if `override` is specified, file will be reloaded even if it was already loaded before
- the transformation rules are as follows: 1) append '.' and the lowercase platform-specific extension of shared libraries (ex. 'dll', 'so'); 2) prepend 'sgs' to file name (TODO: do we really need it? it doesn't work like that now)

    include_module( "json" ); // load the JSON library anywhere


include() [function]

== include( string file[, bool override ] )
=== the umbrella function for @include_library, @include_file, @include_module and @include_shared, attempts to call all of them in the specified order, stops on success or hard failure after any function

- this function is also available as a replicating statement 'include' (ex. 'include "fmt", "io";' works the same way as include("fmt"); include("io");)


import_cfunc() [function]

== import_cfunc( string file, string funcname )
=== retrieves the `funcname` function of the shared library `file`, returns success, as `bool`, emits a warning on failure

! Do not call 'sgscript_main' using this function! That function has different return value semantics so at best, something will work, a warning could be emitted and the worst case is that something will crash.

- `file` must be available according to the platform-specific rules of dynamic libraries (shared objects)

    import_cfunc( "mydll.dll", "someSGScriptFunc" )();


sys_curfile() [function]

== sys_curfile()
=== returns the path of the file (as passed on load) that contains the currently executed code or `null` if the file cannot be determined (eval, C functions)

    // a.sgs
    print( sys_curfile() ); // prints "a.sgs"
    // b.sgs
    include "a.sgs";


sys_print() [function]

== sys_print( int code, string message )
=== passes a message to the internal messaging system (one that's commonly used to report errors and warnings)

! Different codes can be handled differently by the system. By default, SGS_ERROR code will stop execution and return to C code as soon as possible.

- `code` is the code to use to pass the message (ex. SGS_INFO, SGS_WARNING, SGS_ERROR)


sys_abort() [function]

== sys_abort()
=== stops execution and returns to C code as soon as possible

- this function is equivalent to @sgs_Abort in the C API

    sys_abort();
    print( 5 ); // this line is not reached


app_abort() [function]

== app_abort()
=== calls the abort() function of the C standard library (crashes the application)


app_exit() [function]

== app_exit( code = 0 )
=== calls the exit() function of the C standard library (exits the application)


sys_replevel() [function]

== sys_replevel([ level ])
=== returns the current reported error level and optionally sets a new one

! The effects of this function are not reverted automatically at any moment (unless implemented manually with hooks).

    old_level = sys_replevel( SGS_ERROR ); // report only errors or worse
    magic = calculate_magic(); // any warnings are never processed at this point
    sys_replevel( old_level ); // restore the old reported level


sys_stat() [function]

== sys_stat( code )
=== prints info about virtual machine state, everything is implementation-defined

- accepted codes are the same as for @sgs_Stat, which this function is equivalent to

    sys_stat( 11 ); // dumps all globals


errno() [function]

== errno( as_string = false )
=== returns the last relevant error number for the C standard library, as an integer or a string if `as_string` is set

- last relevant error number is defined by @sgs_Errno/@sgs_SetErrno C API functions

    data = io_file_read( "doesnotexist" ); // file that does not exist
    print errno(); // prints 2
    print errno(true); // prints "No such file or directory" on Windows


errno_string() [function]

== errno_string( int code )
=== returns the error string for the given code

- errno_string(errno()) is equivalent to errno(true)

    print errno_string(2); // prints "No such file or directory" on Windows


errno_value() [function]

== errno_value( string key )
=== returns the number for the error key (for "ENOENT" it would return 2)

- this function might be a bit slow considering that it currently does not use any extended lookup systems, such as hash tables

    data = io_file_read( "doesnotexist" );
    if( errno() == error_string("ENOENT") )
        println( "file does not exist" );


dumpvar() [function]

== dumpvar( var, int depth = 5 )
=== similar to @printvar() but returns the dump instead of printing it

- this function is equivalent to @sgs_DumpVar in the C API

    sys_error( SGS_INFO, "Extended variable info:\n" $ dumpvar(data) );


dumpvars() [function]

== dumpvars( ... )
=== similar to @printvars() but returns the dumps, concatenated, instead of printing them


gc_collect() [function]

== gc_collect()
=== runs the garbage collector on the virtual machine, waiting until it has finished

    a = [];
    a.push(a); // creates a circular dependency
    a = null; // a is not actually freed
    gc_collect(); // a is freed now


serialize() [function]

== serialize( var )
=== converts the variable to a byte buffer (string), containing the serialized data that can be recreated with @unserialize() or returns null and emits a warning on failure

- functions and objects without OP_SERIALIZE implemented cannot be serialized (TODO: add the serialization of SGS functions, it's already implemented in pproc)

    data = serialize({ name = "A", info = "B" });
    print data; // prints random-ish garbage
    print unserialize(data); // prints {name=A,info=B}


unserialize() [function]

== unserialize( string data )
=== recreates a variable from the buffer with serialized data or returns null and emits a warning on failure

- this function will internally call global object creation functions specified in the data, so they must be defined and the state could change in the process
- for more info on serialization in SGScript, refer to @Serialization (TODO: what could this possibly lead to?)

    @serialize example


SGS_[INFO|WARNING|ERROR] [constants]

== SGS_INFO, SGS_WARNING, SGS_ERROR are defined to the values of the C macros, respectively 100, 200 and 300


VT_[NULL|BOOL|INT|REAL|STRING|FUNC|CFUNC|OBJECT] [constants]

= these constants are defined to the values of the C macros and can be compared with the values returned in @typeid() or @typeflags()


_G [superglobal]

== A hard-coded global value that points to the global dictionary. Can be used to access non-identifier globals.

    _G["$diff"] = 5; // no way to access this via usual globals


=
== STDLIB/CORE-OBJECTS
=


/////////////////////////////
>>> array

* read-only properties
 - [int] size
 - [int] capacity
 - [cfunc] push
 - [cfunc] pop
 - [cfunc] shift
 - [cfunc] unshift
 - [cfunc] insert
 - [cfunc] erase
 - [cfunc] clear
 - [cfunc] reverse
 - [cfunc] resize
 - [cfunc] reserve
 - [cfunc] sort
 - [cfunc] sort_custom
 - [cfunc] sort_mapped
 - [cfunc] find
 - [cfunc] remove
* other features:
 - read/write integer index
 - full content dump
 - tostring = quick content dump
 - tobool = size != 0
 - iterator
 - cloning
 - serialization
 - GC-safe
 - type identification (returns the string "array")


array.push [method]

== array.push( ... )
=== appends the variables passed to the end of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.push( 6, 7 ).push( 8 ); // a = [5,6,7,8]


array.pop [method]

== array.pop()
=== removes one item from the end of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5 ];
    a.pop(); // array is empty now
    a.pop(); // warning: "array is empty, cannot pop"


array.shift [method]

== array.shift()
=== removes one item from the beginning of array or emits a warning if there are no items in the array, returns the removed item

    a = [ 5, 6 ];
    a.shift(); // a = [6], returned 5


array.unshift [method]

== array.unshift( ... )
=== prepends the variables passed to the beginning of array in the same order, returns the array for chaining

    a = [ 5 ];
    a.unshift( 6, 7 ); // a = [6,7,5] now


array.insert [method]

== array.insert( int pos, ... )
=== inserts the variables passed (all arguments after first) to the position specified in the array or emits a warning on failure (index out of bounds), returns the array for chaining

- `pos` accepts both positive and negative values, the meaning is "which value to insert before"
-- negative values are converted to positive ones by adding (<size> + 1) to them
-- beginning of array can be inserted to using position 0 or (- <size> - 1)
-- end of array can be inserted to using position <size> or -1

    a = [ 5, 7 ];
    a.insert( 1, 6 ); // inserts 6 at position 1 (before item with index 1)
    a.insert( -1, 8 ); // appends to the end of array, a = [5,6,7,8] now


array.erase [method]

== array.erase( int[, int] )
=== erases item or a range of items from the array, depending on the arguments passed or emits a warning on failure, returns the array for chaining

- both arguments have same index processing rules as @array.insert(), but with one difference - if both arguments are passed, after resolving (converting negative indices to positive ones, if there are any), first must be smaller than second

    a = [ 5, 6, 7, 8 ];
    a.erase( 1, 2 ); // erases all items between position 1 and 2, including; gives a = [5,8]
    a.erase( 0 ); // a = [8]


array.clear [method]

== array.clear()
=== erases all items from the array, returns the array for chaining

    a = [ 1, "asd", 8 ];
    a.clear(); // a = []


array.reverse [method]

== array.reverse()
=== reverses the order of items in the original array, returns the original array for chaining

    a = [ 1, 2, 3 ];
    b = a;
    a.reverse(); // a = [3,2,1]
    print( b ); // prints [3,2,1]


array.resize [method]

== array.resize( int size )
=== changes the size of the array, returns the array for chaining

- `size` must be larger than or equal to 0
- if previous size was less than passed to the method, null variables are appended
- if previous size was more than passed to the method, items are popped from the end of the array
- if size was not changed, nothing else will change

    a = [ 5, 6, 7 ];
    a.resize( 5 ); // a = [5,6,7,null,null]
    a.resize( 2 ); // a = [5,6]


array.reserve [method]

== array.reserve( int capacity )
=== reserves the space for the requested number of elements in the array, returns the array for chaining

- `capacity` must be larger than or equal to 0
- if previous capacity was less than passed to the method, capacity will be increased to the requested amount
- if previous capacity was more than or equal to what was passed to the method, nothing will change

    a = [ 5, 6, 7 ];
    a.capacity( 1 ); // nothing happens
    a.capacity( 5 ); // a.capacity = 5 and two variable additions can now happen without reallocations


array.sort [method]

== array.sort([ bool reverse ])
=== sorts the array using the @sgs_Compare C API function for comparisons, returns the array for chaining

- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    a.sort(); // a = [5,6,7,8]


array.sort_custom [method]

== array.sort_custom( callable[, bool reverse ] )
=== sorts the array using the callable for comparisons, returns the array for chaining

! This function is considerably slower than @array.sort or @array.sort_mapped so prefer those if performance matters.

- callable must return an integer, specifying the relative order of the two passed arguments: less than 0 if first variable should be placed before second, greater than 0 if first variable should be placed after second, or 0 if it doesn't matter (TODO: unsafe with big integers/FP return values! something must be done)
- if `reverse` is true, array is sorted in the reverse order

    a = [ 6, 8, 7, 5 ];
    // this code will sort numbers into odd/even ones and in ascending order
    a.sort_custom( function(a,b){return a-b+(b%2-a%2)*1000; } ); // a = [5,7,6,8]


array.sort_mapped [method]

== array.sort_mapped( array map[, bool reverse ] );
=== sorts the array by sorting the passed array and applying the index map to the first one, returns the array for chaining

- both arrays must have the same size, otherwise a warning is emitted
- all variables in the mapping array are interpreted as 'real' values
- if `reverse` is true, array is sorted in the reverse order

    a = [ 5, 6, 7, 8 ];
    b = [ 3, 1, 4, 2 ];
    a.sort_mapped( b ); // a = [6,8,5,7]


array.find [method]

== array.find( var item[, bool strict[, int from ]] )
=== attempts to find `item` in array, starting from 0 or the index passed with `from`, if it exists, using basic or strict equality comparisons (depending on `strict`), returning the index or 'null' if item was not found

- if strict comparisons are enabled, variable types are also checked for equality

    a = [ 5, 6, 7, 8 ];
    a.find( "7" ); // returns 2
    a.find( "7", true ); // returns null


array.remove [method]

== array.remove( var item[, bool strict[, bool all[, int from ]]] )
=== attepts to find and remove first or all `item` variables in array (depending on `all`), according to the rules specified in @array.find(), returning the number of removed items

    a = [ 5, 2, 6, 7, 8, 2 ];
    a.remove( "7" ); // returns 1; a = [5,2,6,8,2]
    a.remove( "6", true ); // returns 0; a remains unchanged
    a.remove( 2, false, true ); // returns 2; a = [5,6,8]



/////////////////////////////
>>> dict

* features:
 - read/write string index
 - read/write string properties and integer index-via-property
 - full content dump
 - tostring = quick content dump
 - tobool = size != 0
 - iterator
 - cloning
 - serialization
 - GC-safe
 - type identification (returns the string "dict")



/////////////////////////////
>>> class

* read/write properties
 - [var] _super
* other features
 - read/write pass-through index
 - read/write pass-through properties (except string "_super")
 - full content dump
 - tobool = ENOTSUP, overridable via "__tobool"
 - toint = ENOTSUP, overridable via "__toint"
 - toreal = ENOTSUP, overridable via "__toreal"
 - tostring = "class", overridable via "__tostring"
 - cloning, overridable via "__clone"
 - type identification (returns the string "class", overridable via "__typeof")
 - overridable arithmetic/comparison operations
 - overridable object call
 - serialization
 - GC-safe



/////////////////////////////
>>> closure
* features
 - full content dump
 - tostring = "closure"
 - type identification (returns the string "closure")
 - object call to callable, using the attached first argument
 - GC-safe


=
== STDLIB/FMT
=


fmt_pack [function]
fmt_pack_count [function]
fmt_unpack [function]
fmt_pack_size [function]
fmt_base64_encode [function]
fmt_base64_decode [function]

fmt_text [function]

== fmt_text( string text, ... )
=== parses all format specifiers in `text` and returns the result

- the general format of a format specifier is as follows: {fmt[size][.prec][r][p<char>]}
-- fmt: one-character output type (b-binary, o-octal, d-decimal, x/X-hexadecimal, f-floating-point, g/G-compact floating-point, e/E-scientific floating-point, s-valid string, c-always converted to string)
-- size: minimum number of characters to print
-- prec: precision of floating-point variables, string length limit
-- r: add "r" to right-pad (left-justify)
-- p<char>: add "p" and any character to set that character as the padding character (default: space/0x20)
- if anything unexpected happens, this function will emit a warning and put "#error#" in the place of a format specifier

    print fmt_text( "{d} -> {x}", 1337, 1337 ); // prints "1337 -> 539"
    print fmt_text( "null: {d}, {s}, {c}", null, null, null ); // prints "null: #error#, #error#, null" and emits two warnings for item 1 and item 2
    print fmt_text( "pi: {f10.10r} {g10r} {E10r}", M_PI, M_PI, M_PI ); // "pi: 3.1415926536 3.14159    3.141593E+000"
    TODO: more useful examples!


fmt_parser [function]

== fmt_parser( callable[, buffersize ] )
=== creates a @fmt_parser object, connected to the callable

- the callable is a function that returns at most the number of bytes requested from the stream
-- if previous request reached end, subsequent requests must return 'null'

    f = io_file( "test.txt", FILE_READ ); // TODO: this is too complex for basic features, add fmt_file_parser
    p = fmt_parser( closure( function(file,num){ if( file.eof() ) return null; return file.read( num ); }, f ) );


fmt_string_parser [function]

== fmt_string_parser( string, offset = 0 )
=== creates a @fmt_parser object, connected to a string reader, initialized to the given offset

    p = fmt_string_parser( "this is a test" );
    p.readcc( "a-z" ); // returns "this"


fmt_charcc [function]

== fmt_charcc( string char, string class )
=== checks if the first character of string `char` is included in the character class `class`

- character class is a regex-like list of specific symbols and ranges (its low and high symbols separated by "-"), optionally prepended by "^" that inverts the scope of the class

    fmt_charcc( ".", "a-zA-Z0-9" ); // returns false
    fmt_charcc( "x", "a-zA-Z0-9" ); // returns true



