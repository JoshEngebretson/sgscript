<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
	<html><head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>SGS/C++ binding compiler</title>
		<link rel="stylesheet" type="text/css" href="docs.css">
		<script type="text/javascript" src="docs.js"></script>
	</head><body>
	<h1>SGS/C++ binding compiler</h1><div><h2>Table of Contents</h2><ul><li><a href='#SGS-CPP-BC-description'>SGS/CPP-BC description</a>
</li><li><a href='#Common-usage-patterns'>Common usage patterns</a>
</li><li><a href='#Tags'>Tags</a>
</li><li><a href='#Data-type-handling'>Data type handling</a>
</li><li><a href='#Helper-classes-functions'>Helper classes &amp; functions</a>
</li></ul></div><div>
<div class='item'><a name='SGS-CPP-BC-description'></a><hr><h2>SGS/CPP-BC description</h2><p>
This is a compiler that will generate most of the binding code from a bit of markup and additional build configuration. Statistically, the gain is approximately 80% less code to write to connect your C++ code to SGScript.
</p><p>
The compiler can be found at &quot;ext/cppbc/cppbc.sgs&quot;. It takes one argument (which should be the header file to process) and it generates one file with the name &quot;cppbc_&quot;+header_file, thus it can be called like this: &quot;sgsvm -p path/to/cppbc.sgs path/to/my_cpp_header.h&quot;.
</p><p>
This is a basic example of how things are done with SGS/CPP-BC:
</p><pre>struct UIFrame
{
	typedef sgsHandle&lt; UIFrame &gt; Handle;
	
	SGS_OBJECT;
	
	UIFrame();
	
	SGS_METHOD void event( UIEvent* e );
	SGS_METHOD void render();
	
	SGS_METHOD void doMouseMove( float x, float y );
	SGS_METHOD void doMouseButton( int btn, bool down );
	SGS_METHOD void doKeyPress( int key, bool down );
	
	SGS_IFUNC(GCMARK) int sgs_gcmark( SGS_CTX, sgs_VarObj* obj, int );
	
	SGS_PROPERTY float x;
	SGS_PROPERTY float y;
	SGS_PROPERTY float width;
	SGS_PROPERTY float height;
	SGS_PROPERTY sgsHandle&lt; UIControl &gt; root;
	
	float prevMouseX;
	float prevMouseY;
};</pre><p>
The SGS_OBJECT tag marks the structs/classes that need to have the binding code. SGS_METHOD would then mark methods that require exporting and SGS_PROPERTY generates property exports. For read-only/write-only properties, all you&#39;d need to add is &quot;READ&quot; or &quot;WRITE&quot; after the tag.
</p><p>
<a href="#sgsVariable-class">sgsVariable</a> and <a href="#sgsHandle-class">sgsHandle</a> are classes that are used to store SGScript objects. Handles are for storing exported object pointers and variables are for everything. Handles make it easier to use the included objects, thus they are preferred to plain variable containers.
</p><p>
GCMARK handlers are more like the raw API but all that needs to be done in the function is calling gcmark() on each variable or handle. Due to the possibility of having many unknown kinds of containers of variables, it is unlikely that this function could ever be automatically generated, except for the most primitive of cases.
</p></div>
<div class='item'><a name='Common-usage-patterns'></a><hr><h2>Common usage patterns</h2><h4>declare a variable and bind it</h4><pre>SGS_PROPERTY float x;</pre><h4>bind an inherited variable</h4><pre>SGS_PROPERTY SGS_ALIAS( float x );</pre><h4>bind &amp; declare variable with post-write callback</h4><pre>SGS_PROPERTY_FUNC( READ WRITE WRITE_CALLBACK myWriteCallback ) float x;</pre><h4>bind a fake variable (based on get/set functions)</h4><pre>SGS_PROPERTY_FUNC( READ getX WRITE setX ) SGS_ALIAS( float x );</pre><h4>bind &amp; declare a variable with two different names</h4><pre>SGS_PROPERTY_FUNC( READ WRITE VARNAME sgsName ) float x;</pre><h4>bind an inherited/previously defined variable</h4><pre>SGS_PROPERTY_FUNC( READ WRITE VARNAME sgsName ) SGS_ALIAS( float x );</pre><h4>declare a method and bind it</h4><pre>SGS_METHOD float calc( float x );</pre><h4>declare a vararg method with variable return value count</h4><pre>SGS_METHOD SGS_MULTRET complexFunc();</pre><h4>handle class stub</h4><pre>typedef sgsHandle&lt; struct sgsObj &gt; sgsObjHandle;
struct sgsObj
{
    SGS_OBJECT;
    
    static sgsObjHandle HandleFromPtr( Obj* ); // resolve the link through object&#39;s user data pointer or some similar method
    
    sgsObj( Obj* obj ) : m_obj( obj ){}
    ~sgsObj(){ cleanup(); }
    void cleanup() // this is pulled out of constructor in case it might be called by a parent object to invalidate the handle on destruction of the owning system
    {
        if( m_obj )
        {
            // *** free m_obj ***
            m_obj = NULL;
        }
    }
    Obj* m_obj;
    
    // declare additional properties and methods with SGS_PROPERTY(_FUNC) and SGS_METHOD, respectively
    // most properties/methods will most likely have to include a NULL test for m_obj, like this:
    int _getProp(){ return m_obj ? m_obj-&gt;GetProp() : 0; }
    void _setProp( int v ){ if( m_obj ) m_obj-&gt;SetProp( v ); }
    SGS_PROPERTY_FUNC( READ _getProp WRITE _setProp ) SGS_ALIAS( int prop );
};</pre><h4>data struct stub</h4><pre>struct sgsData : Data
{
    SGS_OBJECT_LITE;
    
    sgsData(){}
    sgsData( const Data&amp; t ) : Data( t ){}
    
    // properties with direct access (non-private)
    SGS_PROPERTY SGS_ALIAS( item1 );
    
    // data struct properties (original type: SubData, wrapped type: sgsSubData)
    sgsSubData _getSubData(){ return subData; }
    void _setSubData( const sgsSubData&amp; sd ){ subData = sd; }
    SGS_PROPERTY_FUNC( READ _getSubData WRITE _setSubData ) SGS_ALIAS( sgsSubData subData );
    
    // properties with method access
    int _getProp(){ return GetProp(); }
    void _setProp( int v ){ SetProp( v ); }
    SGS_PROPERTY_FUNC( READ _getProp WRITE _setProp ) SGS_ALIAS( int prop );
    
    // aliases (second names) for all properties:
    SGS_PROPERTY_FUNC( READ WRITE VARNAME item1alt ) SGS_ALIAS( item1 );
    SGS_PROPERTY_FUNC( READ _getSubData WRITE _setSubData VARNAME subDataAlt ) SGS_ALIAS( sgsSubData subData );
    SGS_PROPERTY_FUNC( READ _getProp WRITE _setProp VARNAME propAlt ) SGS_ALIAS( int prop );
};
SGS_DEFAULT_LITE_OBJECT_INTERFACE( sgsData ); // this line can be replaced with a modified combo of sgs_PushVar/sgs_GetVar/sgs_GetVarP declarations</pre></div>
<div class='item'><a name='Tags'></a><hr><h2>Tags</h2><h3>SGS_OBJECT</h3><h3>SGS_OBJECT_LITE</h3><p>
Marks the objects/structures for parsing.
</p><p>
SGS_OBJECT_LITE does not add helper variables (sgs_VarObj* m_sgsObject; sgs_Context* C) to the class
</p><h3>SGS_METHOD</h3><p>
Marks the methods that should be made available to the scripting engine.
</p><p>
Syntax: <code>SGS_METHOD &lt;type&gt; &lt;name&gt;(&lt;arguments&gt;);</code>
</p><p>
Alt. syntax (bind without declaration): <code>SGS_METHOD SGS_ALIAS( &lt;type&gt; &lt;name&gt;(&lt;arguments&gt;) );</code>
</p><ul><li>SGS_MULTRET can be used as &lt;type&gt; to allow the return value specify the number of return values pushed (like a usual SGScript C function)</li></ul><h3>SGS_PROPERTY</h3><p>
Marks the properties that should be made available to the scripting engine. Currently supports only one property at a time.
</p><p>
Syntax: <code>SGS_PROPERTY [READ|WRITE] &lt;type&gt; &lt;name&gt;;</code>
</p><p>
Alt. syntax (bind without declaration): <code>SGS_PROPERTY [READ|WRITE] SGS_ALIAS( &lt;type&gt; &lt;name&gt; );</code>
</p><p>
Modifiers:
</p><ul><li>READ: make the property read-only
</li><li>WRITE: make the property write-only</li></ul><h3>SGS_PROPERTY_FUNC</h3><p>
Marks the properties that should be made available to the scripting engine. Has additional options for reading, writing and callbacks.
</p><p>
Syntax: <code>SGS_PROPERTY_FUNC( &lt;tag-args&gt; ) &lt;type&gt; &lt;name&gt;;</code>
</p><p>
Alt. syntax (bind without declaration): <code>SGS_PROPERTY_FUNC( &lt;tag-args&gt; ) SGS_ALIAS( &lt;type&gt; &lt;name&gt; );</code>
</p><p>
Tag arguments: a space separated list of none or more of the following constructs
</p><ul><li>READ: allow to read from the property
</li><li>WRITE: allow to write to the property
</li><li>READ &lt;method&gt;: allow to read from the property, using the specified method
</li><li>WRITE &lt;method&gt;: allow to write to the property, using the specified method
</li><li>READ_CALLBACK &lt;method&gt;: call the specified method after reading from the variable
</li><li>WRITE_CALLBACK &lt;method&gt;: call the specified method after writing to the variable
</li><li>VARNAME: specify a different name for the real variable (more useful with alt. syntax)</li></ul><h3>SGS_IFUNC</h3><p>
Marks the method as a native object interface function that would override any generated one.
</p><p>
Syntax: <code>SGS_IFUNC( &lt;ifunc-type&gt; ) &lt;type&gt; &lt;name&gt;( sgs_Context*, sgs_VarObj*, int );</code>
</p><p>
&quot;ifunc-type&quot; must be one of SGS_OP_* defines.
</p></div>
<div class='item'><a name='Data-type-handling'></a><hr><h2>Data type handling</h2><h3>template&lt; class T &gt; void sgs_PushVar( SGS_CTX, const T&amp; );</h3><h4>pushes the specified variable on the stack, automatically converting it to the most appropriate SGScript type</h4><h3>template&lt; class T &gt; struct sgs_GetVar {  T operator () ( SGS_CTX, int item );  };</h3><h4>takes the specified stack item and converts it to the required type</h4><h3>template&lt; class T &gt; struct sgs_GetVarP {  T operator () ( SGS_CTX, sgs_Variable* var );  };</h3><h3>template&lt; class T &gt; struct sgs_GetVarObjP {  T* operator () ( SGS_CTX, sgs_Variable* var );  };</h3><h4>takes the specified variable and converts it to the required type</h4><ul><li>bindings exist for all basic types (except unsigned int64, since it cannot be represented properly), sgsHandle, sgsVariable, and class pointers</li></ul></div>
<div class='item'><a name='Helper-classes-functions'></a><hr><h2>Helper classes &amp; functions</h2><h4>Classes</h4><ul><li><a href="#sgsHandle-class">sgsHandle</a> - the class used for handling SGS_OBJECT classes
</li><li><a href="#sgsVariable-class">sgsVariable</a> - the class used for handling all SGScript variables</li></ul><h4>Functions</h4><ul><li><a href="#sgs-PushHandle-function">sgs_PushHandle</a> - push handle on stack
</li><li><a href="#sgs-Push-Lite-Class-function">sgs_Push(Lite)Class</a> - push new class instance on stack
</li><li><a href="#sgs-Push-Lite-ClassIPA-function">sgs_Push(Lite)ClassIPA</a> - allocate new class instance, push it on stack
</li><li><a href="#sgs-Push-Lite-ClassFrom-function">sgs_Push(Lite)ClassFrom</a> - push a copy of class instance on stack
</li><li><a href="#sgs-InitPushedClass-function">sgs_InitPushedClass</a> - initialize internal class pointers
</li><li><a href="#sgs-Push-Lite-Class-function">sgs_Push(Lite)Class</a> - push a new instance of class, using the specified arguments for constructor</li></ul></div>
<div class='item'><a name='sgsHandle-class'></a><hr><h2>sgsHandle [class]</h2><h3>template&lt; class T &gt; class sgsHandle</h3><h4>Variables</h4><ul><li><code>sgs_VarObj* object</code> - the pointer to object with interface equal to T::_sgs_interface or NULL
</li><li><code>SGS_CTX</code> (`sgs_Context* C`) - associated context</li></ul><h4>Constructors</h4><ul><li><code>sgsHandle()</code> - initializes a NULL handle
</li><li><code>sgsHandle( const sgsHandle&amp; h )</code> - initializes a handle from another handle
</li><li><code>sgsHandle( sgs_VarObj* obj, sgs_Context* c )</code> - initializes a handle from object pointer if it has the right interface, otherwise handle is initialized to NULL</li></ul><h4>Methods</h4><ul><li><code>SGSRESULT gcmark()</code> - mark the object in handle as accessible (using sgs_ObjGCMark)
</li><li><code>void _acquire()</code> - increment reference count on variable
</li><li><code>void _release()</code> - decrement reference count on variable, remove it from the class</li></ul><h4>Operators</h4><ul><li><code>const sgsHandle&amp; operator = ( const sgsHandle&amp; h )</code> - handle assignment
</li><li><code>operator T*()</code>, <code>operator const T*() const</code> - implicit conversion to valid T* or NULL
</li><li><code>T* operator -&gt; ()</code>, <code>const T* operator -&gt; () const</code> - object access
</li><li><code>bool operator &lt;</code>, <code>bool operator ==</code> - comparison operators (the required minimum used for sorting)</li></ul></div>
<div class='item'><a name='sgsVariable-class'></a><hr><h2>sgsVariable [class]</h2><h3>class sgsVariable</h3><h4>Variables</h4><ul><li><code>sgs_Variable var</code> - the internal variable data
</li><li><code>SGS_CTX</code> (`sgs_Context* C`) - associated context</li></ul><h4>Constructors</h4><ul><li><code>sgsVariable()</code> - initializes a NULL variable
</li><li><code>sgsVariable( const sgsVariable&amp; h )</code> - initializes variable from another variable
</li><li><code>sgsVariable( sgs_Context* c )</code> - initialize a NULL variable and associate context
</li><li><code>sgsVariable( sgs_Context* c, int item )</code> - initialize a variable from current stack frame
</li><li><code>sgsVariable( sgs_Context* c, sgs_Variable* v )</code> - initialize a variable from data pointer</li></ul><h4>Methods</h4><ul><li><code>void push( sgs_Context* c = NULL )</code> - push the variable (optionally specify context if variable might not have it)
</li><li><code>SGSRESULT gcmark()</code> - mark the variable as accessible (using sgs_GCMark)
</li><li><code>bool not_null()</code> - return if variable is not NULL
</li><li><code>bool is_object( sgs_ObjInterface* iface )</code> - check if variable is an object with the specified interface
</li><li><code>template&lt; class T &gt; bool is_handle()</code> - check if variable is an instance of the specified SGS_OBJECT class
</li><li><code>template&lt; class T &gt; T* get_object_data()</code> - get object pointer from variable (WARNING: this method does not do any safety checks)
</li><li><code>void _acquire()</code> - increment reference count on variable
</li><li><code>void _release()</code> - decrement reference count on variable, remove it from the class</li></ul><h4>Operators</h4><ul><li><code>const sgsVariable&amp; operator = ( const sgsVariable&amp; h )</code> - handle assignment
</li><li><code>bool operator &lt;</code>, <code>bool operator ==</code> - comparison operators (the required minimum used for sorting)</li></ul></div>
<div class='item'><a name='sgs-PushHandle-function'></a><hr><h2>sgs_PushHandle [function]</h2><h3>template&lt; class T &gt; inline void sgs_PushHandle( SGS_CTX, const sgsHandle&lt;T&gt;&amp; val )</h3><h4>push the specified class handle on stack</h4><ul><li>NULL is pushed if handle doesn&#39;t point to a class</li></ul></div>
<div class='item'><a name='sgs-Push-Lite-Class-function'></a><hr><h2>sgs_Push(Lite)Class [function]</h2><h3>template&lt; class T &gt; void sgs_PushClass( SGS_CTX, T* inst )</h3><h3>template&lt; class T &gt; void sgs_PushLiteClass( SGS_CTX, T* inst )</h3><h4>push a new instance of the class on stack</h4><p>
<em class='notice-bgr'>This function should not be used with existing instances, as it would make two or more SGScript objects responsible for the same data. Use <a href="#Data-type-handling">sgs_PushVar</a>, <a href="#sgs-PushHandle-function">sgs_PushHandle</a> or <a href="#sgs-Push-Lite-ClassFrom-function">sgs_Push(Lite)ClassFrom</a> with existing instances.</em>
</p></div>
<div class='item'><a name='sgs-Push-Lite-ClassIPA-function'></a><hr><h2>sgs_Push(Lite)ClassIPA [function]</h2><h3>template&lt; class T &gt; T* sgs_PushClassIPA( SGS_CTX )</h3><h3>template&lt; class T &gt; T* sgs_PushLiteClassIPA( SGS_CTX )</h3><h4>allocate a class in-place, push it on the stack</h4><ul><li>To be used with placement new.</li></ul><p>
<em class='notice-bgr'>This function should not be used with existing instances, as it would make two or more SGScript objects responsible for the same data. Use <a href="#Data-type-handling">sgs_PushVar</a>, <a href="#sgs-PushHandle-function">sgs_PushHandle</a> or <a href="#sgs-Push-Lite-ClassFrom-function">sgs_Push(Lite)ClassFrom</a> with existing instances.</em>
</p></div>
<div class='item'><a name='sgs-Push-Lite-ClassFrom-function'></a><hr><h2>sgs_Push(Lite)ClassFrom [function]</h2><h3>template&lt; class T &gt; T* sgs_PushClassFrom( SGS_CTX, T* inst )</h3><h3>template&lt; class T &gt; T* sgs_PushLiteClassFrom( SGS_CTX, const T* inst )</h3><h4>push a copy of the specified class instance on stack</h4></div>
<div class='item'><a name='sgs-InitPushedClass-function'></a><hr><h2>sgs_InitPushedClass [function]</h2><h3>template&lt; class T&gt; T* sgs_InitPushedClass( T* inst, SGS_CTX )</h3><h4>set context / object pointers to class</h4><ul><li>return value is <code>inst</code></li></ul></div>
<div class='item'><a name='SGS-PUSH-LITE-CLASS-function-alias'></a><hr><h2>SGS_PUSH(LITE)CLASS [function alias]</h2><h3>SGS_PUSHCLASS( C, name, args )</h3><h3>SGS_PUSHLITECLASS( C, name, args )</h3><h4>push a new instance of the specified class, using the specified arguments for constructor</h4><ul><li>this is the preferred method to create class object instances
</li><li>returns the pointer to class instance</li></ul><p>
Usage example:
</p><pre>SGS_PUSHCLASS( C, myClass, ( param1, 5.0f ) );</pre></div>
</div>
	</body></html>
	