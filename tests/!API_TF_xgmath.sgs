
global ERRORS;
global tests_failed, tests_ran;

ERRORS = "";
include "sgsxgmath";

testEqual( typeof(vec2), "cfunc", "sgsxgmath library is loaded" );
testEqual( ERRORS, "", "sgsxgmath library loaded without errors" );

//
function section( x ){ print( "\n\t<< ", x, " >>\n" ); }


//
print( "\n\n-- XGMATH --\n" );
//


	section( "vec2" );

v2_a = vec2(3.14159,1/3);
v2_b = vec2(1,2);

testEqual( ''$v2_b, "vec2(1;2)", "vec2 - create/tostring" );
testEqual( ''$(v2_b+vec2(2,3)), "vec2(3;5)", "vec2 - create/ADD/tostring" );
testEqual( ''$(v2_b-vec2(2,3)), "vec2(-1;-1)", "vec2 - create/SUB/tostring" );
testEqual( ''$(v2_b*vec2(2,3)), "vec2(2;6)", "vec2 - create/MUL/tostring" );
testEqual( ''$(vec2(1,4)/vec2(4,2)), "vec2(0.25;2)", "vec2 - create/DIV/tostring" );
testEqual( ''$(vec2(1,4)%vec2(4,2)), "vec2(1;0)", "vec2 - create/MOD/tostring" );
testEqual( vec2(1.5,3) == vec2(1.5,3), true, "vec2 - compare equal" );
testEqual( vec2(1.5,3) == vec2(1,3), false, "vec2 - compare not equal" );
testEqual( vec2_dot(v2_b,vec2(2,3)), 8.0, "vec2_dot" );
testEqual( v2_a === clone(v2_a), true, "vec2 clone returns equal" );
testEqual( toptr(v2_a) != toptr(clone(v2_a)), true, "vec2 clone does not return same" );
testEqual( v2_b.x $ v2_b.y $ v2_b[0] $ v2_b[1], "1212", "vec2 .x, .y" );
testEqual( vec2(5,0).length, 5.0, "vec2 .length" );
testEqual( vec2(0,5).length_squared, 25.0, "vec2 .length_squared" );
testEqual( vec2(2,0).normalized == vec2(1,0), true, "vec2 .normalized" );
testEqual( vec2(1,0).angle, 0.0, "vec2 .angle" );
testEqual( v2_b.perp, vec2(-2,1), "vec2 .perp" );
testEqual( v2_b.perp2, vec2(2,-1), "vec2 .perp2" );
testEqual( vec2(0,0).size, 2, "vec2 .size" );


	section( "vec3" );

v3_a = vec3(3.14159,1/3,2.5);
v3_b = vec3(1,2,3);

testEqual( ''$v3_b, "vec3(1;2;3)", "vec3 - create/tostring" );
testEqual( ''$(v3_b+vec3(2,3,4)), "vec3(3;5;7)", "vec3 - create/ADD/tostring" );
testEqual( ''$(v3_b-vec3(2,3,4)), "vec3(-1;-1;-1)", "vec3 - create/SUB/tostring" );
testEqual( ''$(v3_b*vec3(2,3,4)), "vec3(2;6;12)", "vec3 - create/MUL/tostring" );
testEqual( ''$(vec3(1,4,3)/vec3(4,2,1)), "vec3(0.25;2;3)", "vec3 - create/DIV/tostring" );
testEqual( ''$(vec3(1,4,3)%vec3(4,2,2)), "vec3(1;0;1)", "vec3 - create/MOD/tostring" );
testEqual( vec3(1.5,3,5) == vec3(1.5,3,5), true, "vec3 - compare equal" );
testEqual( vec3(1.5,3,5) == vec3(1.5,3,5.01), false, "vec3 - compare not equal" );
testEqual( vec3_dot(v3_b,vec3(2,3,4)), 20.0, "vec3_dot" );
testEqual( v3_a === clone(v3_a), true, "vec3 clone returns equal" );
testEqual( toptr(v3_a) != toptr(clone(v3_a)), true, "vec3 clone does not return same" );
testEqual( v3_b.x $ v3_b.y $ v3_b.z $ v3_b[0] $ v3_b[1] $ v3_b[2], "123123", "vec3 .x, .y, .z" );
testEqual( vec3(0,0,5).length, 5.0, "vec3 .length" );
testEqual( vec3(0,5,0).length_squared, 25.0, "vec3 .length_squared" );
testEqual( vec3(0,0,2).normalized == vec3(0,0,1), true, "vec3 .normalized" );
testEqual( vec3(0,0,0).size, 3, "vec3 .size" );


//
print( "\n\nTesting finished!\nRan ", tests_ran, " tests of which ", tests_failed, " failed.\n" );
//
