
global ERRORS;
global tests_failed, tests_ran;

//
function section( x ){ print( "\n\t<< ", x, " >>\n" ); }
print( "\n\n-- STRINGS --\n" );
//

var a = "random string";
var b = "WHAT";
var c = "banana";
var d = " \t\r\n \t\r\n spacy \t\r\n \t\r\n ";

	section( "string_cut" );
var string_cut_error_args = "[W:string_cut() - unexpected arguments; function expects 2-4 arguments: string, int, [int], [int]]";
var string_cut_error_range = "[W:string_cut() - invalid character range]";
var string_cut_error_indices = "[W:string_cut() - detected negative indices]";
testEqual( string_cut( a, 3, 5 ), "dom", "string_cut - basic cutting" );
testEqual( string_cut( a, -10, -4 ), "dom str", "string_cut - negative indices" );
testEqual( string_cut( a, 0, 20 ), a, "string_cut - expected positive range overflow" );
testEqual( string_cut( a, -20, -1 ), a, "string_cut - expected negative range overflow" );
testEqual( string_cut( a, 3, 5, fSTRICT_RANGES | fNO_REV_INDEX ), "dom", "string_cut - strict cutting" );
testEqual( string_cut( a, 7 ), 'string', "string_cut - cutting to end" );
ERRORS = ""; testEqual( string_cut( a ), null, "string_cut - bad argument count" ); testEqual( ERRORS, string_cut_error_args );
ERRORS = ""; testEqual( string_cut( null, 0, 10 ), null, "string_cut - string conversion error" ); testEqual( ERRORS, string_cut_error_args );
ERRORS = ""; testEqual( string_cut( a, 0, 20, fSTRICT_RANGES ), null, "string_cut - illegal positive range overflow" ); testEqual( ERRORS, string_cut_error_range );
ERRORS = ""; testEqual( string_cut( a, -20, -1, fSTRICT_RANGES ), null, "string_cut - illegal negative range overflow" ); testEqual( ERRORS, string_cut_error_range );
ERRORS = ""; testEqual( string_cut( a, -20, 20, fSTRICT_RANGES ), null, "string_cut - illegal both range overflow" ); testEqual( ERRORS, string_cut_error_range );
ERRORS = ""; testEqual( string_cut( a, 0, 13, fSTRICT_RANGES ), null, "string_cut - illegal subtle range overflow" ); testEqual( ERRORS, string_cut_error_range );
ERRORS = ""; testEqual( string_cut( a, -5, -3, fNO_REV_INDEX ), null, "string_cut - illegal negative indices" ); testEqual( ERRORS, string_cut_error_indices );

	section( "string_part" );
var string_part_error_args = "[W:string_part() - unexpected arguments; function expects 2-4 arguments: string, int, [int], [int]]";
var string_part_error_range = "[W:string_part() - invalid character range]";
var string_part_error_indices = "[W:string_part() - detected negative indices]";
testEqual( string_part( a, 3, 3 ), "dom", "string_part - basic cutting" );
testEqual( string_part( a, -10, -6 ), "dom str", "string_part - negative indices" );
testEqual( string_part( a, 0, 20 ), a, "string_part - expected positive range overflow" );
testEqual( string_part( a, -20, -1 ), "rando", "string_part - expected negative range overflow" );
testEqual( string_part( a, 3, 3, fSTRICT_RANGES | fNO_REV_INDEX ), "dom", "string_part - basic cutting" );
testEqual( string_part( a, 7 ), 'string', "string_part - cutting to end" );
ERRORS = ""; testEqual( string_part( a ), null, "string_part - bad argument count" ); testEqual( ERRORS, string_part_error_args );
ERRORS = ""; testEqual( string_part( null, 0, 10 ), null, "string_part - string conversion error" ); testEqual( ERRORS, string_part_error_args );
ERRORS = ""; testEqual( string_part( a, 0, 20, fSTRICT_RANGES ), null, "string_part - illegal positive range overflow" ); testEqual( ERRORS, string_part_error_range );
ERRORS = ""; testEqual( string_part( a, -20, -1, fSTRICT_RANGES ), null, "string_part - illegal negative range overflow" ); testEqual( ERRORS, string_part_error_range );
ERRORS = ""; testEqual( string_part( a, -20, 20, fSTRICT_RANGES ), null, "string_part - illegal both range overflow" ); testEqual( ERRORS, string_part_error_range );
ERRORS = ""; testEqual( string_part( a, 0, 14, fSTRICT_RANGES ), null, "string_part - illegal subtle range overflow" ); testEqual( ERRORS, string_part_error_range );
ERRORS = ""; testEqual( string_part( a, -5, -3, fNO_REV_INDEX ), null, "string_part - illegal negative indices" ); testEqual( ERRORS, string_part_error_indices );

	section( "string_reverse" );
var string_reverse_error_args = "[W:string_reverse() - unexpected arguments; function expects 1 argument: string]";
testEqual( string_reverse( a ), "gnirts modnar", "string_reverse - output (odd number of chars)" );
testEqual( string_reverse( "action" ), "noitca", "string_reverse - output (even number of chars)" );
testEqual( typeof( string_reverse( "" ) ), "string", "string_reverse - empty strings" );
ERRORS = ""; testEqual( string_reverse(), null, "string_reverse - bad argument count" ); testEqual( ERRORS, string_reverse_error_args );
ERRORS = ""; testEqual( string_reverse( null ), null, "string_reverse - string conversion error" ); testEqual( ERRORS, string_reverse_error_args );

	section( "string_pad" );
var string_pad_error_args = "[W:string_pad() - unexpected arguments; function expects 2-4 arguments: string, int, [string], [int]]";
testEqual( string_pad( b, 8 ), "  WHAT  ", "string_pad - output (even padding)" );
testEqual( string_pad( b, 9 ), "   WHAT  ", "string_pad - output (odd padding)" );
testEqual( string_pad( b, 9, 'pad' ), "padWHATad", "string_pad - custom padding string" );
testEqual( string_pad( b, 8, 'pad', fLEFT ), "padpWHAT", "string_pad - left padding only" );
testEqual( string_pad( b, 8, 'pad', fRIGHT ), "WHATadpa", "string_pad - right padding only" );
testEqual( string_pad( b, 3 ), b, "string_pad - output (no padding)" );
testEqual( string_pad( b, 100, a, 1<<4 ), b, "string_pad - no (recognized) flags specified" );
ERRORS = ""; testEqual( string_pad( b, 0, a, 0, 0 ), null, "string_pad - too many arguments" ); testEqual( ERRORS, string_pad_error_args );

	section( "string_repeat" );
var string_repeat_error_args = "[W:string_repeat() - unexpected arguments; function expects 2 arguments: string, int (>= 0)]";
testEqual( string_repeat( b, 3 ), b$b$b, "string_repeat - positive count" );
testEqual( string_repeat( b, 0 ), '', "string_repeat - zero count" );
ERRORS = ""; testEqual( string_repeat( b, -3 ), null, "string_repeat - negative count" ); testEqual( ERRORS, string_repeat_error_args );

	section( "string_count" );
var string_count_error_args = "[W:string_count() - unexpected arguments; function expects 2-3 arguments: string, string (length > 0), [bool]]";
testEqual( string_count( a, "ran" ), 1, "string_count - 1 match at beginning" );
testEqual( string_count( a, "ring" ), 1, "string_count - 1 match at end" );
testEqual( string_count( a, "box" ), 0, "string_count - 0 matches" );
testEqual( string_count( c, "a" ), 3, "string_count - multiple matches" );
testEqual( string_count( c, "an" ), 2, "string_count - multiple following matches" );
testEqual( string_count( c, "ana" ), 1, "string_count - overlapping matches (disabled)" );
testEqual( string_count( c, "ana", true ), 2, "string_count - overlapping matches (enabled)" );
ERRORS = ""; testEqual( string_count( c, "" ), null, "string_count - zero-length substring" ); testEqual( ERRORS, string_count_error_args );

	section( "string_find" );
	section( "string_replace" );
	section( "string_tolower" );
	section( "string_toupper" );
	section( "string_compare" );

	section( "string_trim" );
testEqual( string_trim( d ), "spacy", "string_trim - basic space trimming" );
testEqual( string_trim( d, d ), "", "string_trim - trim everything" );
testEqual( string_trim( c, "ba", fLEFT ), "nana", "string_trim - trim from left only" );
testEqual( string_trim( c, "an", fRIGHT ), "b", "string_trim - trim from right only" );
testEqual( string_trim( c, c, 1<<4 ), c, "string_trim - no (recognized) flags specified" );


//
print( "\n\n-- TYPES --\n" );
//

	section( "is_* - strict" );
var is_null_error_args = "[W:is_null: 1 argument expected]";
var _N = null, _B = true, _I = 1, _R = 1.0, _S = "1", _F = section, _C = print, _O = [];
testEqual( is_null( _N ) && !is_null( _B ) && !is_null( _I ) && !is_null( _R ) &&
	!is_null( _S ) && !is_null( _F ) && !is_null( _C ) && !is_null( _O ), true, "is_null - all tests" );
testEqual( !is_bool( _N ) && is_bool( _B ) && !is_bool( _I ) && !is_bool( _R ) &&
	!is_bool( _S ) && !is_bool( _F ) && !is_bool( _C ) && !is_bool( _O ), true, "is_bool - all tests" );
testEqual( !is_int( _N ) && !is_int( _B ) && is_int( _I ) && !is_int( _R ) &&
	!is_int( _S ) && !is_int( _F ) && !is_int( _C ) && !is_int( _O ), true, "is_int - all tests" );
testEqual( !is_real( _N ) && !is_real( _B ) && !is_real( _I ) && is_real( _R ) &&
	!is_real( _S ) && !is_real( _F ) && !is_real( _C ) && !is_real( _O ), true, "is_real - all tests" );
testEqual( !is_string( _N ) && !is_string( _B ) && !is_string( _I ) && !is_string( _R ) && 
	is_string( _S ) && !is_string( _F ) && !is_string( _C ) && !is_string( _O ), true, "is_string - all tests" );
testEqual( !is_func( _N ) && !is_func( _B ) && !is_func( _I ) && !is_func( _R ) &&
	!is_func( _S ) && is_func( _F ) && !is_func( _C ) && !is_func( _O ), true, "is_func - all tests" );
testEqual( !is_cfunc( _N ) && !is_cfunc( _B ) && !is_cfunc( _I ) && !is_cfunc( _R ) &&
	!is_cfunc( _S ) && !is_cfunc( _F ) && is_cfunc( _C ) && !is_cfunc( _O ), true, "is_cfunc - all tests" );
testEqual( !is_object( _N ) && !is_object( _B ) && !is_object( _I ) && !is_object( _R ) && 
	!is_object( _S ) && !is_object( _F ) && !is_object( _C ) && is_object( _O ), true, "is_object - all tests" );
ERRORS = ""; testEqual( is_null(), null, "is_null - no arguments" ); testEqual( ERRORS, is_null_error_args );
ERRORS = ""; testEqual( is_null( _N, _B ), null, "is_null - too many arguments" ); testEqual( ERRORS, is_null_error_args );

	section( "is_* - convertible" );
testEqual( !is_numeric( _N ) && is_numeric( _B ) && is_numeric( _I ) && is_numeric( _R ) &&
	!is_numeric( _F ) && !is_numeric( _C ) && !is_numeric( _O ), true, "is_numeric - basic tests" );
testEqual( is_numeric( _S ), true, "is_numeric - numeric string" );
testEqual( is_numeric( c ), false, "is_numeric - non-numeric string" );
testEqual( is_numeric( "1E+2" ) && is_numeric( "-123.456" ) && is_numeric( "0x7f" ) &&
	is_numeric( "0b101" ) && is_numeric( "01234" ) && is_numeric( "0o427" ), true, "is_numeric - extra numeric formats" );
testEqual( !is_callable( _N ) && !is_callable( _B ) && !is_callable( _I ) && !is_callable( _R ) &&
	!is_callable( _S ) && is_callable( _F ) && is_callable( _C ), true, "is_callable - basic tests" );
testEqual( is_callable( _O ), false, "is_callable - non-callable object" );
testEqual( is_callable( closure( print, _O ) ), true, "is_callable - callable object" );
testEqual( is_switch( _N ) && is_switch( _O ) && !is_switch( closure( print, _O ) ), true, "is_switch - non-numeric type tests" );
testEqual( is_switch( _B ) == is_numeric( _B ) && is_switch( _I ) == is_numeric( _I ) &&
	is_switch( _R ) == is_numeric( _R ) && is_switch( _S ) == is_numeric( _S ) &&
	is_switch( c ) == is_numeric( c ), true, "is_switch - numeric type tests" );
testEqual( !is_printable( _N ) && is_printable( _B ) && is_printable( _I ) && is_printable( _R ) &&
	is_printable( _S ) && !is_printable( _F ) && !is_printable( _C ) && is_printable( _O ), true, "is_printable - basic tests" );

	section( "type_*" );
testEqual( type_get( _N ) == tNULL && type_get( _B ) == tBOOL && type_get( _I ) == tINT &&
	type_get( _R ) == tREAL && type_get( _S ) == tSTRING && type_get( _F ) == tFUNC &&
	type_get( _C ) == tCFUNC && type_get( _O ) == tOBJECT, true, "type_get - basic tests" );
var typenames = [ "null", "bool", "int", "real", "string", "func", "cfunc", "object" ];
var srcvars = [ _N, _B, _I, _R, _S, _F, _C, _O ];
var expect =
[
	tNULL, tNULL, tNULL, tNULL, tNULL, tNULL, tNULL, tNULL,
	tBOOL, tBOOL, tBOOL, tBOOL, tBOOL, tBOOL, tBOOL, tBOOL,
	tINT, tINT, tINT, tINT, tINT, tINT, tINT, tNULL,
	tREAL, tREAL, tREAL, tREAL, tREAL, tREAL, tREAL, tNULL,
	tSTRING, tSTRING, tSTRING, tSTRING, tSTRING, tSTRING, tSTRING, tSTRING,
	tNULL, tNULL, tNULL, tNULL, tNULL, tFUNC, tNULL, tNULL,
	tNULL, tNULL, tNULL, tNULL, tNULL, tNULL, tCFUNC, tNULL,
	tNULL, tNULL, tNULL, tNULL, tNULL, tNULL, tNULL, tOBJECT,
];
for( var i = 0; i < t_COUNT; ++i )
{
	for( var j = 0; j < t_COUNT; ++j )
	{
		testEqual( type_get( type_cast( srcvars[ j ], i ) ), expect[ i * t_COUNT + j ], "type_cast test - " $ typenames[ j ] $ " -> " $ typenames[ i ] );
	}
}


//
print( "\n\nTesting finished!\nRan ", tests_ran, " tests of which ", tests_failed, " failed.\n" );
//
